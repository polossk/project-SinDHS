---
layout: post
title: "[NWPU][2014][TRM][1] 是时候表演真正的团队合作了！"
date: 2014-07-14 12:00:48 +0800
categories: contest solution
tags: realcombat
---
题目来源[<a href="http://vjudge.net/contest/view.action?cid=49507#overview" target="_blank">Portal</a>]

# A

数学问题，给一个m，给一个n，m的k次方可以整除n的阶乘（n!），求最大的k。

质因数分解问题。不妨设m = r1 ^ k1 * r2 ^ k2 * ... * rm ^ km，n = r1 ^ l1 * r2 ^ l2 * ... * rm ^ lm * r[m+1] ^ l[m+1] * ... * rn ^ ln。

正解就是最小的(l[i] / k[i])了。

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRM][1] A
#       @file         :A.cpp
#       @date         :2014/07/13 20:00
#       @algorithm    :Number Theory
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;
template<class T>inline bool updateMin(T& a, T b){ return a > b ? a = b, 1: 0; }

int t, tt, m, n;

int getSum(int n, int x)
{
    int ans = 0;
    while (n) ans += n / x,  n /= x;
    return ans;
}

void solve()
{
    cin >> m >> n;
    printf("Case %d:n", ++tt);
    int i = 2, ans = 1000000000, tmp = 0;
    while (m > 1)
    {
        int a = 0;
        while (m % i == 0) m /= i, a++;
        if (a) tmp = getSum(n, i) / a, updateMin(ans, tmp);
        if (i == 2) i--;
        i += 2;
    }
    if (ans) printf("%dn", ans);
    else puts("Impossible to divide");
}

int main()
{
    cin >> t; while (t--) solve();
    return 0;
}{% endhighlight %}

# B

同样是质因数分解问题，也就是对于两个数a, b，他们的最小公倍数k = lcm(a, b) ，问有多少组a, b的组合。

分解质因数，然后拼起来就行了。

对于一个数p，如果p的分解质因数的结果是p = r1 ^ a1 * r2 ^ a2 * r3 ^ a3 * ... * rm ^ am。那么他就会有(a1 + 1)(a2 + 1)(a3 + 1)...(am + 1)个约数。

然后对于一些特殊的数据，比如202 = 2 * 101， 在分解质因数的时候只能找到2找不到101这个数， 所以这个时候要把这个也乘上去，也就是乘以3。不过我们计算时都是将(a, b)和(b, a)同时计算的，所以最后(ans + 1) / 2。

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRM][1] B
#       @file         :B.cpp
#       @date         :2014/07/13 20:00
#       @algorithm    :Number Theory
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;

typedef long long int64;
int64 n;

void solve()
{
    int64 ntemp = n;
    int64 cnt = 0, ans = 1;
    for (int64 i = 2; i * i <= n; i += 2)
    {
        if (n % i == 0)
        {
            cnt = 0;
            while (n % i == 0) n/= i, cnt++;
            ans *= (cnt << 1) + 1;
        }
        if (i == 2) i--;        // 从3开始接着分解质因数
    }
    if (n > 1) ans += ans << 1; // ans = ans * 3;
    ans = (ans >> 1) + 1;       // ans = (ans + 1) / 2
    cout << ntemp << " " << ans << endl;
}

int main()
{
    while (cin >> n && n) solve();
    return 0;
}{% endhighlight %}

# C

统计a到b有多少个0，问题转化为从0开始，分别到a和到b的数量的差。然后就是无聊的统计了，一位一位的去计算即可。

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRM][1] C
#       @file         :C.cpp
#       @date         :2014/07/13 20:00
#       @algorithm    :Counting
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;
typedef long long int64;

int64 m, n;
int64 exp_10[20] = { 1 };

void init()
{
    for (int i = 1; i < 20; i++)
		exp_10[i] = exp_10[i - 1] * 10;
}

int64 calc(int64 b)
{
	if (b < 0) return 0;

	char s[20]; sprintf(s, "%lld", b);
	int n = strlen(s);

	int64 suf[20]; suf[n] = 0;
	for (int i = n - 1; i >= 0; i--)
		suf[i] = suf[i + 1] + (s[i] - '0') * exp_10[n - i - 1];

	int64 res = 1, pref = 0;
	for (int i = 1; i < n; i++)
    {
		pref = pref * 10 + (s[i - 1] - '0');
		if (s[i] != '0') // 第二位是否为零
			res += pref * exp_10[n - i - 1];
		else
			res += (pref - 1) * exp_10[n - i - 1] + suf[i + 1] + 1;
	}
	return res;
}

int main()
{
	init();
	while (cin >> m >> n && m != -1 && n != -1)
        cout << calc(max(m, n)) - calc(min(m, n) - 1) << endl;
}{% endhighlight %}

# D

典型的隐式图搜索问题。首先定义状态，也就是用当前的两个水杯的盛了多少水作为状态量。然后定义转换的方法，总共有6种。接着是定义各种各样的过程量，父节点fa，步骤数step，访问vis， 还有方法method，最后就是套用BFS的模板了，建队列，搜索，记录；路径用递归的方法输出。

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRM][1] D
#       @file         :D.cpp
#       @date         :2014/07/13 20:00
#       @algorithm    :BFS
******************************************************************************/

#include <queue>
#include <stack>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

typedef pair<int, int> state;
int a, b, c;

bool vis[110][110];
int step[110][110], fa[110][110];
int method[110][110];

inline bool inbound(int x, int r, int l = 0)
{
    return x <= r && x >= 0;
}

inline int encode(int x, int y) { return x * 100 + y; }

inline state FILL_1(state past) { return make_pair(a, past.second); }

inline state FILL_2(state past) { return make_pair(past.first, b); }

inline state DROP_1(state past) { return make_pair(0, past.second); }

inline state DROP_2(state past) { return make_pair(past.first, 0); }

inline state POUR_1(state past)
{
    int pa = past.first, pb = past.second;
    int na = 0, nb = 0;
    int dt = pb + pa - b;
    if (dt > 0) na = dt, nb = b;
    else na = 0, nb = pa + pb;
    return make_pair(na, nb);
}

inline state POUR_2(state past)
{
    int pa = past.first, pb = past.second;
    int na = 0, nb = 0;
    int dt = pb + pa - a;
    if (dt > 0) nb = dt, na = a;
    else nb = 0, na = pa + pb;
    return make_pair(na, nb);
}

inline state newState(state p, int flag)
{
    switch (flag)
    {
    case 0: return FILL_1(p);
    case 1: return FILL_2(p);
    case 2: return DROP_1(p);
    case 3: return DROP_2(p);
    case 4: return POUR_1(p);
    case 5: return POUR_2(p);
    default: return p;
    }
}

void METHODPRINTER(int method)
{
    switch (method)
    {
    case 0: puts("FILL(1)"); return;
    case 1: puts("FILL(2)"); return;
    case 2: puts("DROP(1)"); return;
    case 3: puts("DROP(2)"); return;
    case 4: puts("POUR(1,2)"); return;
    case 5: puts("POUR(2,1)"); return;
    default: return;
    }
}

void path_Print(int x, int y)
{
    stack<int> dir;
    while (true)
    {
        int fx = fa[x][y] / 100;
        int fy = fa[x][y] % 100;
        if (fx == x && fy == y) break;
        dir.push(method[x][y]);
        x = fx; y = fy;
    }
    while (!dir.empty())
    {
        METHODPRINTER(dir.top());
        dir.pop();
    }
}

bool bfs(int& fx, int& fy)
{
    memset(method, 0, sizeof(method));
    memset(step, 0, sizeof(step));
    memset(vis, 0, sizeof(vis));
    memset(fa, 0, sizeof(fa));
    vis[0][0] = 1, fa[0][0] = 0;
    queue<state> q; q.push(make_pair(0, 0));
    while (!q.empty())
    {
        state top = q.front(); q.pop();
        int na = top.first, nb = top.second;
        if (na == c || nb == c)
        {
            fx = na, fy = nb;
            return 1;
        }
        for (int j = 0; j < 6; j++)
        {
            state tmp = newState(top, j);
            int xa = tmp.first, xb = tmp.second;
            if (inbound(xa, a) && inbound(xb, b) && !vis[xa][xb])
            {
                q.push(make_pair(xa, xb));
                vis[xa][xb] = 1;
                step[xa][xb] = step[na][nb] + 1;
                fa[xa][xb] = encode(na, nb);
                method[xa][xb] = j;
            }
        }
    }
    return 0;
}

void solve()
{
    int fx = 0, fy = 0;
    if (bfs(fx, fy))
    {
        printf("%dn", step[fx][fy]);
        path_Print(fx, fy);
    }
    else puts("impossible");
}

int main()
{
    while (~scanf("%d%d%d", &a, &b, &c)) solve();
    return 0;
}{% endhighlight %}

# E

问一个数列排序后某一个数的位置，直接用hash统计就行了。

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRM][1] E
#       @file         :E.cpp
#       @date         :2014/07/13 20:00
#       @algorithm    :Hash
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;

vector<int> v;
int number[10001];
int tt, n, q;

void solve()
{
    v.clear();
    memset(number, 0, sizeof(number));
    v.resize(n);
    for (int i = 0; i < n; i++)
        cin >> v[i];
    sort(v.begin(), v.end());
    for (int i = 0; i < n; i++)
        if(number[v[i]] == 0) number[v[i]] = i + 1;
    while (q--)
	{
        int t; cin >> t;
        if (number[t] == 0) cout << t << " not found" << endl;
        else cout << t << " found at " << number[t] << endl;
    }
}

int main()
{
    while (cin >> n >> q && n && q)
	{
        cout << "CASE# " << ++tt << ":n";
        solve();
    }
    return 0;
}{% endhighlight %}

# F

二分检索就行，没什么特别的难度。

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRM][1] F
#       @file         :F.cpp
#       @date         :2014/07/13 20:00
#       @algorithm    :Binary Search
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;
int n, mm[10005], num[10005];

bool search(int a, int b, int key)
{
    if (a > b) return 0;
    int mid = (a + b) / 2;
    if (mm[mid] == key) return 1;
    if (mm[mid] > key)
		return search(a, mid - 1, key);
    else
		return search(mid + 1, b, key);
}

void init()
{
	for (int i = 1; i <= 10000; i++)
		mm[i] = i * i;
	for (int i = 10000; i >= 1; i--)
    {
		for (int j = i - 1; j >= 1; j--)
		{
			int tt = i * i - j * j;
			if (tt > j * j) break;
			if (search(1, 10000, tt))
				num[i]++;
		}
	}
}

void solve()
{
    int sum = 0;
	for (int i = 1; i <= n; i++)
		sum += num[i];
	printf("%dn", sum);
}

int main()
{
    init();
    while (~scanf("%d",&n)) solve();
	return 0;
}{% endhighlight %}

# G

问日期间隔，转换为分别计算从1900/01/01到目标日期的时间就行了。

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRM][1] G
#       @file         :G.cpp
#       @date         :2014/07/13 20:00
#       @algorithm    :Simulation
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;

inline int isLeapyear(int yy) { return yy % (yy % 100? 4: 400)? 0: 1; }

int day[2][12]={
    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
	{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

int calday(int yy, int mm, int dd)
{
    int sum=0;
    for (int i = 1900; i < yy; i++)
        if (isLeapyear(i))  sum += 366;
        else                sum += 365;
    int p = isLeapyear(yy);
    for (int i = 1; i < mm; i++)
        sum += day[p][i - 1];
    sum += dd;
    return sum;
}

int days(string a)
{
    int yy = (a[0] - '0') * 1000 + (a[1] - '0') * 100 + (a[2] - '0') * 10 + (a[3] - '0');
    int mm = (a[5] - '0') * 10 + (a[6] - '0');
    int dd = (a[8] - '0') * 10 + (a[9] - '0');
    return calday(yy, mm, dd);
}

int main(){
    string a, b;
    while (cin >> a >> b)
        cout << abs(days(a) - days(b)) << endl;
    return 0;
}{% endhighlight %}
