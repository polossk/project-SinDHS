---
layout: post
title: "POJ 3009 Curling 2.0 深搜"
date: 2014-07-03 01:24:47 +0800
categories: contest serach
tags: acmicpc poj dfs
---
题目地址<a title="POJ 3009" href="http://poj.org/problem?id=3009" target="_blank">-></a>

题目意思是说，一个冰球在S点，可以向4个方向打出。如果碰到了砖块，就会停下来，而且那个砖块也会消失；如果碰到了墙壁，那么就失败了。如果在这些之前就到了终点G，那么就成功了。所以问最小多少次抛出冰球后，可以成功。

另外注意一点就是，如果抛出次数大于10次，那么就默认这次行动失败。

对四个方向深搜就行了，由于和平时的走迷宫之类的不一样，需要一直走到头才行，故在代码中稍微处理一下就行了。

具体的看代码吧。

Code Here
{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :POJ 3009
#       @file         :G:My Source Code[ACM] 训练702 - 搜索poj3009.cpp
#       @date         :2014/07/02 14:33
#       @algorithm    :DFS
******************************************************************************/

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long int64;
int w, h, res;
int gird[25][25];
//driection   u,  d,  r,  l;
int dx[4] = { 0,  0,  1, -1};
int dy[4] = {-1,  1,  0,  0};

inline bool inbound(int l, int r, int x)
{
    return (x >= l && x < r);
}

inline bool check(int x, int y)
{
    return inbound(0, w, x) && inbound(0, h, y);
}

void dfs(int cnt, int x, int y)
{
    int cx = 0, cy = 0;
    bool flag = false;
    if (cnt > 10) return;
    for (int i = 0; i < 4; i++)
    {
        flag = false;
        if (gird[x + dx[i]][y + dy[i]] == 1)
            continue;
        cx = x, cy = y;
        while (1)
        {
            cx += dx[i], cy += dy[i];
            if (!check(cx, cy)) break;
            if (gird[cx][cy] == 1) { flag = true; break; }
            if (gird[cx][cy] == 3) { res = min(res, cnt); break; }
        }
        if (flag)
        {
            gird[cx][cy] = 0;
            dfs(cnt + 1, cx - dx[i], cy - dy[i]);
            gird[cx][cy] = 1;
        }
    }
}

void solve()
{
    memset(gird, 0, sizeof(gird));
    res = 11;
    int sx = 0, sy = 0;
    for (int i = 0; i < h; i++)
    for (int j = 0; j < w; j++)
    {
        scanf(" %d", &gird[j][i]);
        if (gird[j][i] == 2) sx = j, sy = i;
    }
    dfs(1, sx, sy);
    if (res > 10)   printf("-1n");
    else            printf("%dn", res);
}

int main()
{
    while (scanf("%d%d", &w, &h))
    {
        if (w == 0 && h == 0) break;
        else solve();
    }
    return 0;
}{% endhighlight %}
