---
layout: post
title: "ZOJ 2859 Matrix Searching 二维RMQ问题"
date: 2013-10-02 21:08:31 +0800
categories: contest datastructure
tags: acmicpc zoj rmq
---
题目地址<a title="ZOJ 2859" href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2859" target="_blank">-></a>

题目显然是RMQ问题，而且是二维的。

大意是讲，给定一个n*n(n <= 300)的矩阵，然后是(T <= 10^6)次询问，每次询问某个子矩阵中的最小值。

想必大家对RMQ问题不是特别陌生，说起来，ST算法的核心就在于“二分”，当然不是传统意义上的二分了，毕竟是二维的，要分类来进行二分处理。

简单地说，定义dp[row][col][i][j] 表示[row,row+2^i-1] x [col,col+2^j-1] 二维区间内的最小值。

那么，有：

<blockquote>dp[row][col][i][j] =

min( [row,row+ 2^(i-1)-1] x [col,col+2^j-1] ,

[row+2^(i-1),row+2^i-1] x [col,col+2^j-1] )

（左半区的最小值 和 右半区的最小值）

= min( dp[row][col][i-1][j] , dp[row + (1<<(i-1))][col][i-1][j] )

（左半区的最小值 和 右半区的最小值，相当于固定了y轴坐标不变，将区域分割成左右两个区）
</blockquote>

同样的，也有：

<blockquote>dp[row][col][i][j]=

= min( [row,row+ 2^i-1] x [col,col+2^(j-1)-1] ,

[row,row+2^i-1] x [col+2^(i-1),col+2^j-1])

（上半区的最小值 和 下半区的最小值）

= min( dp[row][col][i][j-1] ,

dp[row][col + (1<<(i-1))][i][j-1] )

（上半区的最小值 和 下半区的最小值，相当于固定了x轴坐标不变，将区域分割成上下两个区）
</blockquote>

时间复杂度是O(N * M * log N * log M)

空间复杂度是O(N * M * log N * log M)

已经非常的高效了。

Code Here

{% highlight cpp %}
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

const int maxn = 310;

int N;
int val[maxn][maxn];

//2D RMQ
//dp[row][col][i][j] 表示[row,row+2^i-1]x[col,col+2^j-1] 二维区间内的最小值.
//dp[row][col][i][j] = 
//	min( dp[row][col][i-1][j], dp[row + (1<<(i-1))][col][i-1][j] )
//    	min( dp[row][col][i][j-1], dp[row][col + (1<<(j-1))][i][j-1] )

int code(int i){
    return log(double(i)) / log(2.0);
}

int dp[maxn][maxn][9][9];
void initRMQ(int N,int M){
	for (int row=1;row<=N;row++){
	for (int col=1;col<=M;col++){
		dp[row][col][0][0]=val[row][col];
	}
	}
	int n = code(N);
	int m = code(M);
	for (int i=0;i<=n;i++){
	for (int j=0;j<=m;j++){
		if(i == 0 && j==0)continue;
		for (int row=1;row+(1<<i)-1<=N;row++){
		for (int col=1;col+(1<<j)-1<=M;col++){
			if (i==0){//水平划分
				dp[row][col][i][j] = min(dp[row][col][i][j-1] , dp[row][col+(1<<(j-1))][i][j-1]);
			}
			else {//竖直划分
				dp[row][col][i][j] = min(dp[row][col][i-1][j] , dp[row+(1<<(i-1))][col][i-1][j]);
			}
		}
		}
	}
	}
}

int RMQ(int x1,int x2,int y1,int y2){
	int kx = code(x2-x1+1);
	int ky = code(y2-y1+1);
	int m1 = dp[x1][y1][kx][ky];
	int m2 = dp[x2-(1<<kx)+1][y1][kx][ky];
	int m3 = dp[x1][y2-(1<<ky)+1][kx][ky];
	int m4 = dp[x2-(1<<kx)+1][y2-(1<<ky)+1][kx][ky];
	return min( min(m1,m2), min(m3,m4) );
}


int main(){
	int T;
	int M;
	int x1,y1,x2,y2;
	scanf("%d",&T);
	while(T--){
		scanf("%d",&N);
		for(int i=1; i<=N; i++) {
			for(int j=1; j<=N; j++) {
				scanf("%d",&val[i][j]);
			}
		}
		initRMQ(N,N);
		scanf("%d",&M);
		while(M--)	{
			scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
			printf("%dn",RMQ(x1,x2,y1,y2));
		}
	}
	return 0;
}{% endhighlight %}
