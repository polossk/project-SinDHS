---
layout: post
title: "UVa 120 Stacks of Flapjacks 另类排序模拟"
date: 2013-12-21 13:00:47 +0800
categories: contest serach
tags: acmicpc uva basicsearch
---
题目地址<a title="UVa 120" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=98&page=show_problem&problem=56" target="_blank">-></a>

给你一叠薄煎饼，请你写一个程序来指出要如何安排才能使这些薄煎饼由上到下依薄煎饼的半径由小到大排好。 所有的薄煎饼半径均不相同。 要把薄煎饼排好序需要对这些薄煎饼做翻面（flip）的动作。 方法是以一抹刀插入一叠薄煎饼中，然后做翻面的动作（也就是说在抹刀上面的薄煎饼经翻 面后，会依相反的次序排列）。 若一叠共有n个薄煎饼，我们定义最底下的薄煎饼的位置为1，最上面的薄煎饼位置为n。 当抹刀插入位置为k时，代表从位置k到 位置n的薄煎饼要做翻面的动作。 一开始时，这叠薄煎饼随意堆放，并以半径大小来表示。 例如：以下3叠薄煎饼（最左边那一叠8是最上面一个薄煎饼的半径）

Code Here

{% highlight cpp %}
/****
	*@PoloShen
	*Title:UVaOJ 120
	*/
#include <algorithm>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <deque>
using namespace std;

vector<string> num;
deque<int> Stack;
string line;

void Read(){
	istringstream stream(line);
	int tempNum;
	while (stream >> tempNum){
		Stack.push_front(tempNum);
	}
}

void solve(){
	num.clear();
	Stack.clear();
	cout << line << endl;
	num.clear();
	Stack.clear();
	Read();
	for (deque<int>::iterator it = Stack.begin(); it != Stack.end(); it++){
		deque<int>::iterator iMax = max_element(it, Stack.end());
		if (iMax != it){
			if (iMax != Stack.end() - 1){
				reverse(iMax, Stack.end());
				cout << distance(Stack.begin(), iMax) + 1 << ' ';
			}
			reverse(it, Stack.end());
			cout << distance(Stack.begin(), it) + 1 << ' ';
		}
	}
	cout << '0' << endl;
}

int main(){
	while (getline(cin, line)){
		solve();
	}
    return 0;
}{% endhighlight %}
