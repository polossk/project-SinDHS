---
layout: post
title: "FZU 2108 Mod problem 模运算"
date: 2014-01-25 21:15:09 +0800
categories: contest math
tags: acmicpc fzu numbertheory mod
---
题目地址<a title="FZU 2108" href="http://acm.fzu.edu.cn/problem.php?pid=2108" target="_blank">-></a>

题目意思好混乱，先解释一下。有一种新的数字表示方式方法[w]v表示的是w这个数字节重复v次，比如[1024]2其实表示的就10241024。

然后这个表示方法可以并列、嵌套使用，比如：

<blockquote>[35]3[7]1 = 3535357;

[[1024]2]2 = [10241024]2 = 1024102410241024;
</blockquote>


回到正题，题目就是给你一个A，用这个数字表示方式，再给一个B，求A%B。

这里用到了一些模运算。

一般的讲，模这个代数空间是对加法和乘法封闭的，另外，严格意义上，模这个空间是欧氏向量空间，对加法运算而言，它是一个加法阿贝尔群（满足交换律，并且是加法群），对乘法是一个乘法半幺群，因为逆元非唯一性。所以，换句话说，很多对整数成立的运算法则对这个空间也成立。比如说：

<blockquote>加法结合律：a+b+c = a+(b+c)，a+b+c≡a+(b+c)(mod M)

加法交换律：a+b=b+a，a+b≡(b+a)(mod M)

乘法结合律：a*b*c=a*(b*c)，a*b*c≡a*(b*c)(mod M)

左乘分配律：(a+b)*c=a*c+b*c，(a+b)*c≡a*c+b*c(mod M)

右乘分配率：a*(b+c)=a*b+a*c，a*(b+c)≡a*b+a*c(mod M)
</blockquote>


那么我唠叨这么多有什么用呢？其实就在于我们计算这些数据中用到了。

比如说[123]2=123123=123*1000+123。那么如果B=11，我们所要计算的就是：

[123]2 % 11 = 123123 % 11 = 123*1000 % 11 + 123 % 11.

接着化简下去，记a = 123 % 11，m = 1000 % 11.

ans = (a * m % 11 + a) % 11.

对于这个m，我们可以用快速幂计算其值，而其他的就剩下简单的分解与累加的问题了，这些都不是难事。

数学上的难题解决了，剩下的就是用深搜把这个数据从字符串还原出来，这就是编码问题了。

Code Here

{% highlight cpp %}
/****
	*@PoloShen
	*Title:G
	*/
#include <iostream>
#include <string>

using namespace std;
typedef long long int64;

int64 q_mul_mod(int64 a,int64 b,int64 m){
	int64 t = 0; a %= m; b %= m;
	while (b){
		if (b&1){ t += a;
			if  (t >= m) t -= m;
		}
		a <<= 1; b >>= 1;
		if (a >= m) a -= m;
	}
	return t;
}

int64 q_pow_mod(int64 a, int64 b, int64 m){
	int64 ans = 1;
	a %= m;
	while (b){
		if (b&1){
			ans = q_mul_mod(ans, a, m);
			b--;
		}
		b /= 2;
		a = q_mul_mod(a, a, m);
	}
	return ans;
}

int64 mod; string s;
inline int64 qmul(int64 a, int64 b){ return q_mul_mod(a, b, mod); }
inline int64 qmod(int64 a, int64 k){ return q_pow_mod(a, k, mod); }

struct num{
    int64 length;
    int64 value;
    num(){length = 0;value = 0;}
    num(int64 l, int64 v){length = l;value = v;}
};

num build(int l,int r){
	num p, t;
	int i,flag = 0;
	int left = 0, right = 0, cnt = 0;
	for (i = l; i <= r; i++){
		if (s[i] == '['){
            if (flag == 0) left = i + 1;
            flag++;
        }
		else if (s[i] == ']'){
			flag--;
			if (flag == 0){
				right = i - 1;
				i++;
				cnt = s[i] - '0';
				t = build(left, right);
				int64 base = qmod(10, t.length);
				int64 g = 1,e = base;
				p.length += cnt * t.length;
				p.value = qmul(p.value, qmod(base, cnt));
				while (--cnt){
					g += e;
					g %= mod;
					e = qmul(e, base);
				}
				t.value = qmul(t.value, g);
				p.value = (p.value + t.value) % mod;
			}
		}
		else if (flag == 0){
			p.value = p.value * 10 + s[i] - '0';
			p.value %= mod;
			p.length++;
		}
	}
	p.value %= mod;
	return p;
}

void solve(){
    cin >> s >> mod;
    num ans = build(0, s.size() - 1);
    cout << ans.value << endl;
}

int main(){
	int t; cin >> t;
	while (t--) solve();
	return 0;
}{% endhighlight %}
