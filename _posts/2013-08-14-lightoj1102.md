---
layout: post
title:  "LightOJ 1102 组合数求模"
date:   2013-08-14 21:37:00 +0800
categories: contest math
tags: acmicpc lightoj combination cmod
---

题目地址[->](http://www.lightoj.com/volume_showproblem.php?problem=1102)

题目的意思是将整数n分解成k份有多少种分解方式。

# 数学求解

首先可以发现，这是一道典型的数学问题，我们先假设其所求的真实结果为M(n,k),其中0 ≤ n ≤ 106 ，1 ≤ k ≤ 106。

两个参数，我们先固定一个，方便我们去查找规律。

当n=1时，显然只有1种情况，所以有M(0,k)=1，其中0 ≤ k ≤ 106 。

当k=1时，显然只有1种情况，所以有M(n,1)=1，其中0 ≤ n ≤ 106 。

当k=2时，我们不妨假设n=4，那么有如下5种结果

（0，4），（1，3），（2，2），（3，1），（4，0）；

那么显然了，对于任意的n，只要n不为零，我们就有M(n,1)=n+1，其中1 ≤ n ≤ 106。

当k=3时，我们不妨仍然假设n=4，此时仔细观察我们的题目中所给例子。例子中，排列方式显然是先固定第一位，然后考虑其他两位数字的排列。

我为大家建立一个表格，方便大家发现规律。

首位数字为 0，共 5 种（0，0，4）（0，1，3）（0，2，2）（0，3，1）（0，4，0）

首位数字为 1，共 4 种（1，0，3）（1，1，2）（1，2，1）（1，3，0）

首位数字为 2，共 3 种（2，0，2）（2，1，1）（2，2，0）

首位数字为 3，共 2 种（3，0，1）（3，1，0）

首位数字为 4，共 1 种（4，0，0）

如果大家眼睛十分敏锐的话，相信大家已经发现了规律

M(4,3) = M(4,2) + M(3,2) + M(2,2) + M(1,2) + M(0,2)

如果没能看出来，麻烦您自己写以下M(4,2)，M(3,2)，M(2,2)，M(1,2)，M(0,2)，相信您就能看到为什么我这样写了。

现在新的问题是，这个规律是否具有一般性。

现在我们来自行定义我们刚才所做的：

对于一个M(n,k)，在1 ≤ n ≤ 106的情况下，我们先固定其首位的取值，依次考察M(n,k-1)，M(n-1,k-1)，M(n-2,k-1)，...，M(1,k-1)，M(0,k-1)；

对于每一个新的M(n‘,k’)，我们重复刚才的所做，直到所有的k为2。

这样一来，我们便证明了这是一个一般性的规律，接下来的问题就是计算了。

先回到k=2的情况下，我们当时草草的下了“当k=2时，有M(n,1)=n+1，其中1 ≤ n ≤ 106”的结论下面我们来证明：

对于k=2的情况，当我们确定首位的数字后，显然末位数字也就固定了，且有

（r，n-r），其中0 ≤ r ≤ n

故r的取值情况有n+1种。

在n+1种情况下选1种情况，答案很明显是C(n+1,1)，

C是组合数的记号

那么对于k=3，k=4，k=5等等又该如何计算呢？

同样的，我们从简单的入手，试图去找到一般规律。

当k=3，n=4时，我们已经有了刚才我们发现的公式

    M(4,3) = M(4,2) + M(3,2) + M(2,2) + M(1,2) + M(0,2)

下面我们将他化简。

{% highlight plain %}
M(4,3) = M(4,2) + M(3,2) + M(2,2) + M(1,2) + M(0,2)
= C(5,1) + C(4,1) + C(3,1) + C(2,1) + C(1,1)
{% endhighlight %}

这个时候怎么来化简呢？难道用求和公式么？这显然不是我们所期望的结果。求和公式只能对已知的公式求和，这样的话我们需要手工计算n次，显然不现实。其实只要大家的数学底子好，上面的式子不难接着化简：

{% highlight plain %}
M(4,3) = M(4,2) + M(3,2) + M(2,2) + M(1,2) + M(0,2)
= C(5,1) + C(4,1) + C(3,1) + C(2,1) + C(1,1)
= C(5,1) + C(4,1) + C(3,1) + C(2,1) + C(2,2)//C(n,n)=1=C(n+1,n+1)
= C(5,1) + C(4,1) + C(3,1) + C(3,2) //C(n,r) + C(n,r+1) =C(n+1,r+1)
= C(5,1) + C(4,1) + C(4,2)
= C(5,1) + C(5,2)
= C(6,2)
{% endhighlight %}

如果实在有困难，希望你能在杨辉三角的帮助下解决问题。

那么显然有

{% highlight plain %}
M(n,3) = M(n,2) + M(n-1,2) + M(n-2,2) + ... + M(1,2) + M(0,2)
= C(n+1,1) + C(n,1) + C(n-1,1) + ... + C(2,1) + C(1,1)
= C(n+1,1) + C(n,1) + C(n-1,1) + ... + C(2,1) + C(2,2)
= C(n+1,1) + C(n,1) + C(n-1,1) + ... + C(3,2)
= ...
= C(n+1,1) + C(n+1,2)
= C(n+2,2)
{% endhighlight %}

同样的用上述方法去化简我们会得到一连串的结果：

当k=3时，M(n,3) = C(n+2,2)；

当k=4时，M(n,4) = C(n+3,3)；

当k=5时，M(n,5) = C(n+4,4)；

...

我们可以总结M(n,k) = C(n+k-1,k-1)；

严格的证明可以用数学归纳法，不再赘述。

再考虑到最最开始的范围限制（一定不要忘记，我在这里WA了3次），我们可以写出求解的代码：

{% highlight cpp %}
int64 solve(int64 n,int64 k){
	if (k==1){
		return 1;
	}
	else if (n==0){
		return 1;
	}
	else return C(n+k-1,k-1);
}
{% endhighlight %}

# 具体编程求解 

由于题目中要求结果对1,000,000,007取模，显然不能用传统的组合数计算公式，应当使用快速组合数求模的一般方法，即只处理组合数计算即可，没有用到Lucas定理，当然用了更不会错。具体方法如下：

当然首先为大家介绍Lucas定理，该定理是一切计算的前提：

Lucas定理：

设p是一个素数（一般，题目中要求取模的数也是素数），将n,m均转化为p进制数，表示如下：

$$m = \sum_{i = 0}^k {m_i p^i}, n = \sum_{i = 0}^k {n_i p^i}$$

满足下式：

$$\binom{m}{n} = \prod_{i=0}^{k}{\binom{m_i}{n_i}} \pmod p$$


即C(n,m)模p等于p进制数上各位的C(ni,mi)模p的乘积。利用该定理，可以将计算较大的C(n,m)转化成计算各个较小的C(ni,mi)。这样一来，基本上可以将组合数的计算时间复杂度降到常数到对数之间。

现在将简单伪代码为大家呈上：
{% highlight cpp %}
int64 C(int64 n,int64 m){
	int64 x,y;
	int64 a=m! * (n-m)! % 1000000007;
	int64 b=1000000007;
	int64 d=gcd_ex(a,b,x,y);//d=gcd(a,b)
	//a*x+b*y=gcd(a,b)
	x=(x % 1000000007 + 1000000007) % 1000000007;
	return n! * x % 1000000007;
}
int64 Lucas(int64 n,int64 m){
	if (m==0){
		return 1;
	}
	int n1,n2,m1,m2;
	n1=n % 1000000007;n2=n / 1000000007;
	m1=m % 1000000007;m2=m / 1000000007;
	int c1,c2;
	c1=C(n1,m1);
	c2=Lucas(n2,m2);
	return c1 * c2 % 1000000007;
}
{% endhighlight %}
为了保险起见，当然也是实际需要，里面的乘法必须使用快速乘法取模，否则还是有可能溢出（WA了一次，TLE一次）。

# Code Here
{% highlight cpp %}
/****
	*@Polo-shen
	*
	*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
typedef long long int64;

#define DBG 0
#define ShowLine DBG && cout<<__LINE__<<">>| "
#define dout DBG && cout<<__LINE__<<">>| "
#define write(x) #x" = "<<(x)<<", "

using namespace std;
const int64 MOD=1000000007;
const int64 MAXN=2000010;
int64 N,M;
class Combinations_Mod_without_Lucas{
//将所有用到的函数封装进这个类中
public:
	int64 fac[MAXN];//阶乘数组
	//快速乘法取模，计算a*b mod m
	int64 q_mul_mod(int64 a,int64 b,int64 m){
		a%=m;
		b%=m;
		int64 t=0;
		while (b){
			if (b&1){
				t+=a;
				if (t>=m)
					t-=m;
			}
			a<<=1;
			if (a>=m)a-=m;
			b>>=1;
		}
		return t;
	}
	//预处理阶乘
	void facterial(){
		fac[1]=1;
		for (int i=2;i<MAXN;i++){
			fac[i]=q_mul_mod(fac[i-1],i,MOD);
		}
	}
	//快速乘方取模，计算a^b mod m
	int64 q_pow_mod(int64 a,int64 b,int64 m){
		int64 ans=1;
		a%=m;
		while (b){
			if (b&1){
				ans=q_mul_mod(ans,a,m);
				b--;
			}
			b/=2;
			a=q_mul_mod(a,a,m);
		}
		return ans;
	}
	//扩展欧几里得，返回值为gcd(a,b)
	//gcd(a,b)=a*x+b*y
	int64 gcd_ex(int64 a,int64 b,int64& x,int64& y){
		if (b==0){
			x=1;
			y=0;
			return a;
		}
		int64 d=gcd_ex(b,a%b,x,y);
		int64 t=x;
		x=y;
		y=t-a/b*y;
		return d;
	}
	//一般的组合数公式
	int64 C(int64 n,int64 m){
		int64 x,y;
		int64 temp=gcd_ex(q_mul_mod(fac[m],fac[n-m],MOD),MOD,x,y);
		x=(x%MOD+MOD)%MOD;
		return q_mul_mod(fac[n],x,MOD);
	}
	//Lucas方法
	int64 Lucas(int64 n,int64 m){
		if (m==0){
			return 1;
		}
		return q_mul_mod(C(n%MOD,m%MOD),Lucas(n/MOD,m/MOD),MOD);
	}
}cm;//cm是这个类的一个实例

//本题的主要求解
int64 solve(int64 n,int64 k){
	if (k==1){
		return 1;
	}
	else if (n==0){
		return 1;
	}
	else return cm.C(n+k-1,k-1);
}

int main (){
	int T,tt=1;
	int64 n,k;cm.facterial();
	cin>>T;
	while (T--){
		cin>>n>>k;
		int64 ans;
		ans=solve(n,k);
		cout<<"Case "<<tt++<<": "<<ans<<endl;
	}
	return 0;
}
{% endhighlight %}