---
layout: post
title: "LightOJ 1307 Counting Triangles 二分查找"
date: 2014-05-20 23:27:23 +0800
categories: contest algorithm
tags: acmicpc lightoj bsearch
---
题目地址<a title="LightOJ 1307" href="http://lightoj.com/volume_showproblem.php?problem=1307" target="_blank">-></a>

二分查找题，题意就是从集合中选长度拼三角形。其实就是暴力枚举两个边，然后第三个便就可以二分查找的方法从集合中找出来。当然集合要事先排好序。最后最坑爹的一点是数据int过不去，需要全部改成longlong。其他的就没什么了。大部分都是相同的代码。

Code Here
{% highlight cpp %}
/****
	*@author    Shen
	*@title     LightOj 1307
	*/

#include <iostream>
#include <climits>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
typedef long long int64;

const int maxN = 2005;
int64 a[maxN];
int t, tt;
int n;

int64 Bsearch_lower_bound(int64 x)
{
    int64 l = 0, r = n - 1, mid = 0;
    while (l <= r)
    {
        mid = (l + r) >> 1;
        if (a[mid] < x) l = mid + 1;
        else r = mid - 1;
    }
    return l;
}

int64 Bsearch_upper_bound(int64 x)
{
    int64 l = 0, r = n - 1, mid = 0;
    while (l <= r)
    {
        mid = (l + r) >> 1;
        if (a[mid] <= x) l = mid + 1;
        else r = mid - 1;
    }
    return l;
}

void solve()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    sort(a, a + n);
    int64 cnt = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < i; j++)
        {
            int64 x = a[i] - a[j];
            int64 y = a[i] + a[j];
            int64 t1 = Bsearch_lower_bound(x + 1);
            int64 t2 = Bsearch_upper_bound(y - 1);
            cnt += (t2 - t1);
            if ((i >= t1) && (i <= t2)) cnt--;
            if ((j >= t1) && (j <= t2)) cnt--;
        }
    }
    printf("Case %d: %dn", ++tt, cnt / 3);
}

int main()
{
    scanf("%d", &t);
    while (t--) solve();
    return 0;
}{% endhighlight %}
