---
layout: post
title: "[比赛记录] Codeforces Round #225 (Div. 1)"
date: 2014-01-22 15:51:58 +0800
categories: contest solution
tags: codeforces
---
# A. Milking cows

0朝左看，1朝右看，看到有牛被挤奶产量会降低1。一开始挺难想。后来感觉上可以直接走“一”遍。

考虑这个情况：2 0 1，不论如何挤奶，答案都是2；那么3 0 1 0呢？答案是1，因为不管怎么挤奶，总会有牛看到。那么推广的说，对于一个数列，只要满足不全为1或不全为0（因为这样的结果显然为0）的一个数列，肯定会有牛看到被挤奶，所以其实这个问题的关键不是在于用什么方案去挤奶，而是数列本身出现形如“0 1”或者“1 0”的子列的数量。注意，如果你一旦计算的是“1 0”，请只计算“1 0”。问题就变成计数问题了，求一个数列的逆序对数。由于这个数列全是0与1，直接一遍走下来就行了。

{% highlight cpp %}
#include <cstdio>
#include <algorithm>

using namespace std;

const int INF = 1000000100;

struct range {
    int x, y;
} prev[100010], cur[100010], blocked[100010];

inline bool comp1(range A, range B) {
    if (A.x == B.x)
        return A.y < B.y;
    return A.x < B.x;
}

int main() {
    int N, M;
    scanf("%d%d", &N, &M);
    for (int i = 1; i <= M; ++i) {
        int xx, yy;
        scanf("%d%d", &xx, &yy);
        blocked[i].x = xx; blocked[i].y = yy;
    }

    sort(blocked + 1, blocked + M + 1, comp1);
    int curCnt = 0, prevCnt = 1;
    prev[prevCnt].x = prev[prevCnt].y = 1;

    for (int i = 1; i <= M; ++i) {
        if (blocked[i].x != blocked[i - 1].x + 1) {
            prevCnt = 1;
            prev[1].y = N;
        }

        int j;
        for (j = i; j <= M && blocked[j].x == blocked[i].x; ++j); --j;
        curCnt = 0;
        int leftSegment = 1;
        for (int k = i; k <= j; ++k) {
            if (blocked[k].y - 1 >= leftSegment) {
                cur[++curCnt].x = leftSegment;
                cur[curCnt].y = blocked[k].y - 1;
            }
            leftSegment = blocked[k].y + 1;
        }
        if (leftSegment <= N) {
            cur[++curCnt].x = leftSegment;
            cur[curCnt].y = N;
        }

        for (int k = 1; k <= curCnt; ++k) {
            int st = 1, dr = prevCnt, ret = -1;
            while (st <= dr) {
                int med = (st + dr) / 2;
                if (prev[med].y >= cur[k].x) {
                    ret = prev[med].x;
                    dr = med - 1;
                } else
                    st = med + 1;
            }
            if (ret == -1 || ret > cur[k].y)
                cur[k].x = cur[k].y = INF;
            else
                cur[k].x = max(ret, cur[k].x);
        }

        prevCnt = 0;
        for (int k = 1; k <= curCnt; ++k)
            if (cur[k].x != INF && cur[k].y != INF)
                prev[++prevCnt] = cur[k];
        if (prevCnt == 0) {
            printf("-1");
            return 0;
        }
        i = j;
    }

    if (blocked[M].x != N) {
        prevCnt = 1;
        prev[1].y = N;
    }

    if (prev[prevCnt].y == N)
        printf("%dn", 2 * N - 2);
    else
        printf("-1");
    return 0;
}{% endhighlight %}

# B. Volcanoes

{% highlight cpp %}#include <cstdio>
#include <algorithm>

using namespace std;

const int INF = 1000000100;

struct range {
    int x, y;
} prev[100010], cur[100010], blocked[100010];

inline bool comp1(range A, range B) {
    if (A.x == B.x)
        return A.y < B.y;
    return A.x < B.x;
}

int main() {
    int N, M;
    scanf("%d%d", &N, &M);
    for (int i = 1; i <= M; ++i) {
        int xx, yy;
        scanf("%d%d", &xx, &yy);
        blocked[i].x = xx; blocked[i].y = yy;
    }

    sort(blocked + 1, blocked + M + 1, comp1);
    int curCnt = 0, prevCnt = 1;
    prev[prevCnt].x = prev[prevCnt].y = 1;

    for (int i = 1; i <= M; ++i) {
        if (blocked[i].x != blocked[i - 1].x + 1) {
            prevCnt = 1;
            prev[1].y = N;
        }

        int j;
        for (j = i; j <= M && blocked[j].x == blocked[i].x; ++j); --j;
        curCnt = 0;
        int leftSegment = 1;
        for (int k = i; k <= j; ++k) {
            if (blocked[k].y - 1 >= leftSegment) {
                cur[++curCnt].x = leftSegment;
                cur[curCnt].y = blocked[k].y - 1;
            }
            leftSegment = blocked[k].y + 1;
        }
        if (leftSegment <= N) {
            cur[++curCnt].x = leftSegment;
            cur[curCnt].y = N;
        }

        for (int k = 1; k <= curCnt; ++k) {
            int st = 1, dr = prevCnt, ret = -1;
            while (st <= dr) {
                int med = (st + dr) / 2;
                if (prev[med].y >= cur[k].x) {
                    ret = prev[med].x;
                    dr = med - 1;
                } else
                    st = med + 1;
            }
            if (ret == -1 || ret > cur[k].y)
                cur[k].x = cur[k].y = INF;
            else
                cur[k].x = max(ret, cur[k].x);
        }

        prevCnt = 0;
        for (int k = 1; k <= curCnt; ++k)
            if (cur[k].x != INF && cur[k].y != INF)
                prev[++prevCnt] = cur[k];
        if (prevCnt == 0) {
            printf("-1");
            return 0;
        }
        i = j;
    }

    if (blocked[M].x != N) {
        prevCnt = 1;
        prev[1].y = N;
    }

    if (prev[prevCnt].y == N)
        printf("%dn", 2 * N - 2);
    else
        printf("-1");
    return 0;
}{% endhighlight %}
