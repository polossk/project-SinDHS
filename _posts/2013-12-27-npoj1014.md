---
layout: post
title: "NPOJ(BETA) 1014 蚂蚁来报数(NWPU SRM2 of 2013.Dec D题) dp & 数学"
date: 2013-12-27 23:47:30 +8000
categories: contest math dp
tags: acmicpc nwpuacm lindp cmod combination
---
# 题目

<h2 style="color: blue;">1014: 蚂蚁来报数

<span class="green" style="color: green;">Time Limit: </span>2 Sec  <span class="green" style="color: green;">Memory Limit: </span>64 MB

<span class="green" style="color: green;">Submit: </span>14  <span class="green" style="color: green;">Solved: </span>3

[<a style="color: #1a5cc8;" href="http://192.168.0.101/JudgeOnline/submitpage.php?id=1014" target="_blank">Submit</a>][<a style="color: #1a5cc8;" href="http://192.168.0.101/JudgeOnline/problemstatus.php?id=1014" target="_blank">Status</a>][<a style="color: #1a5cc8;" href="http://192.168.0.101/JudgeOnline/bbs.php?pid=1014" target="_blank">Web Board</a>]

<h2 style="color: blue;">Description

<div class="content">
n只蚂蚁从多维空间回来以后都感觉晕乎乎的，大家准备排成一排报个数。由于头晕，大家报的数有点乱，但是每个蚂蚁都仍清醒地知道自己报的数要大于等于前一个蚂蚁报的数并都遵守了这个规则。在遵守这个规则的前提下，每个蚂蚁可以从[1,m]m个正整数之内任意挑选一个来报。第一个蚂蚁就1-m任意报了。

请问，根据上述情况，n只蚂蚁共有多少种不同的合法报数序列呢。

</div>
<h2 style="color: blue;">Input

<div class="content">
输入有多测试组数据（不超过30组），每组数据占一行，有两个正整数n，m（n,m<=100）。

</div>
<h2 style="color: blue;">Output

<div class="content">
将每组测试数据结果对100000007取模输出，每组答案占一行。


<h2 style="color: blue;">Sample Input

<div class="content"><span class="sampledata">2 1</span></div>
<div class="content"><span class="sampledata">1 2</span></div>
<h2 style="color: blue;">Sample Output

<div class="content"><span class="sampledata">2</span></div>
<div class="content"><span class="sampledata">1</span></div>
<h2 style="color: blue;">Source

<div class="content">
<a style="color: #1a5cc8;" href="http://192.168.0.101/JudgeOnline/problemset.php?search=NWPU%20ACM%202013.12%E6%9C%88%E8%B5%9B" target="_blank">NWPU ACM 2013.12月赛</a>
</div>
# 题解

首先，NPOJ(BETA)是我们学校的在线OJ系统，正在内部封测，鄙人有幸作为测试员也是非常的开心：）正式上线的时候杂家一定会奔走相告的！

然后声明下，这个题目吧，其是我们队员自己出的，而且呢，不得不说题目很新颖，并且这个题目通过数据量压缩的方法保证两种方法都能解。下面简单介绍下两种解法。

## 解法一：DP（时间复杂度O(m^3 * n)，空间复杂度O(m^2 * n)）

怎么说呢，我为了方便表达这个解，我用A(m, n)来表达，其中m表示报数数字上限，n表示多少人。同时，假设第一人所报的数为a，统计此时的排列方式为P(a, m, n)。那么，对于每一个n的情况，只需要暴力的将所有的P(a, m, n)枚举一遍即可得出正确解。so，这样的时间复杂度是O(m^3 * n)，数据量因为比较小，暴力DP可过。

## 解法二：数学方法求解题通用公式（近似时间空间复杂度O(N)）

这个问题，报数，后一个人大于等于前一个人，可以理解成，m分成n份的不同分解方式。那么就有A(m, n) = C(m+n-1, n-1)。这个的具体推导我的博客中曾经写过一篇，使用到了二项式定理。[<a title="LightOJ 1102 组合数求模" href="{% post_url 2013-08-14-lightoj1102 %}" target="_blank">传送门</a>]

代码示例

解法一：

{% highlight cpp %}
/****
	*@Polo-shen
	*
	*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
typedef long long int64;

using namespace std;
const int64 MOD=100000007;
const int64 MAXN=2000010;
int64 N,M;
class Combinations_Mod_without_Lucas{
//将所有用到的函数封装进这个类中
public:
	int64 fac[MAXN];//阶乘数组
	//快速乘法取模，计算a*b mod m
	int64 q_mul_mod(int64 a,int64 b,int64 m){
		a%=m;
		b%=m;
		int64 t=0;
		while (b){
			if (b&1){
				t+=a;
				if (t>=m)
					t-=m;
			}
			a<<=1;
			if (a>=m)a-=m;
			b>>=1;
		}
		return t;
	}
	//预处理阶乘
	void facterial(){
		fac[1]=1;
		for (int i=2;i<MAXN;i++){
			fac[i]=q_mul_mod(fac[i-1],i,MOD);
		}
	}
	//快速乘方取模，计算a^b mod m
	int64 q_pow_mod(int64 a,int64 b,int64 m){
		int64 ans=1;
		a%=m;
		while (b){
			if (b&1){
				ans=q_mul_mod(ans,a,m);
				b--;
			}
			b/=2;
			a=q_mul_mod(a,a,m);
		}
		return ans;
	}
	//扩展欧几里得，返回值为gcd(a,b)
	//gcd(a,b)=a*x+b*y
	int64 gcd_ex(int64 a,int64 b,int64& x,int64& y){
		if (b==0){
			x=1;
			y=0;
			return a;
		}
		int64 d=gcd_ex(b,a%b,x,y);
		int64 t=x;
		x=y;
		y=t-a/b*y;
		return d;
	}
	//一般的组合数公式
	int64 C(int64 n,int64 m){
		int64 x,y;
		int64 temp=gcd_ex(q_mul_mod(fac[m],fac[n-m],MOD),MOD,x,y);
		x=(x%MOD+MOD)%MOD;
		return q_mul_mod(fac[n],x,MOD);
	}
}cm;//cm是这个类的一个实例

//本题的主要求解
int64 solve(int64 n,int64 k){
	if (k==1){
		return 1;
	}
	else if (n==0){
		return 1;
	}
	else return cm.C(n+k-1,k-1);
}

int main (){
	int64 n,k;cm.facterial();
	while (cin>>k>>n){
		int64 ans;
		ans=solve(n,k);
		cout<<ans<<endl;
	}
	return 0;
}{% endhighlight %}
