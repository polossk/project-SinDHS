---
layout: post
title: "[比赛记录] Codeforces Round #257 (Div. 2)"
date: 2014-07-20 00:46:32 +0800
categories: contest solution
tags: codeforces
---
# A. Jzzhu and Children

没什么大难度，用STL的队列直接模拟就行了。

不想用结构体，所以就开了两个队列，分别维护物品数量和id。两个队列同时操作就好了。

{% highlight cpp %}
/******************************************************************************
*       COPYRIGHT NOTICE
*       Copyright (c) 2014 All rights reserved
*       ----Stay Hungry Stay Foolish----
*
* @author		:Shen
* @name         :A
* @file         :G:My Source Code[ACM] 比赛719 - CFA.cpp
* @date         :2014/07/19 20:57
* @algorithm    :Simulation
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;
template<class T>inline bool updateMin(T& a, T b){ return a > b ? a = b, 1 : 0; }
template<class T>inline bool updateMax(T& a, T b){ return a < b ? a = b, 1 : 0; }

int n, m, tmp;
int a[105];

int main()
{
    cin >> n >> m;
    queue<int> id, cand;
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
        id.push(i + 1); cand.push(a[i]);
    }
    while (id.size() != 1)
    {
        int top = cand.front();
        int x = id.front();
        //cout << x << " " << top << endl;
        if (top > m)
        {
            id.pop(); cand.pop();
            id.push(x); cand.push(top - m);
        }
        else
        {
            cand.pop(); id.pop();
        }
    }
    int res = id.front();
    cout << res << endl;
    return 0;
}{% endhighlight %}

B. Jzzhu and Sequences

很简单的一个递推法的题目，我直接用矩阵快速幂去过了。

构造方法也很简单。

f1 + f3 = f2

f3 = f2 - f1

f3 = 1 * f2 + -1 * f1

f2 = 1 * f2 + 0 * f1


所以矩阵就是

1， -1

1， 0

然后就是取模运算和负数处理了。负数取模会返回负数。因为我是快速幂的写法，最后返回的数一定是在(-Mod, Mod)之间的，所以直接加上一个Mod，然后再取一次模就好了。

{% highlight cpp %}
/******************************************************************************
*       COPYRIGHT NOTICE
*       Copyright (c) 2014 All rights reserved
*       ----Stay Hungry Stay Foolish----
*
* @author		:Shen
* @name         :B
* @file         :G:My Source Code[ACM] 比赛719 - CFB.cpp
* @date         :2014/07/19 20:57
* @algorithm    :Matrix Fast Power Method
******************************************************************************/

#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long int64;

const int MAXN = 2;
const int MAXM = 2;
const int Mod = 1000000007;

struct Matrax{
    int n, m;
    int64 mat[MAXN][MAXM];
    Matrax(): n(-1), m(-1){}
    Matrax(int _n, int _m): n(_n), m(_m){
        memset(mat, 0, sizeof(mat));
    }
    void Unit(int _s){
        n = _s; m = _s;
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n; j++){
                mat[i][j] = (i == j)? 1: 0;
            }
        }
    }
    void print(){
        printf("n = %d, m =  %dn", n, m);
        for (int i = 0; i < n; i++){
            for (int j = 0; j < m; j++)
                printf("%8d", mat[i][j]);
            printf("n");
        }
    }
};

Matrax add_mod(const Matrax& a,const Matrax& b,const int64 mod){
    Matrax ans(a.n, a.m);
    for (int i = 0; i < a.n; i++){
        for (int j = 0; j < a.m; j++){
            ans.mat[i][j] = (a.mat[i][j] + b.mat[i][j]) % mod;
        }
    }
    return ans;
}

Matrax mul(const Matrax& a,const Matrax& b){
    Matrax ans(a.n, b.m);
    for (int i = 0; i < a.n; i++){
        for (int j = 0; j < b.m; j++){
            int64 tmp = 0;
            for (int k = 0; k < a.m; k++){
                tmp += a.mat[i][k] * b.mat[k][j];
            }
            ans.mat[i][j] = tmp;
        }
    }
    return ans;
}

Matrax mul_mod(const Matrax& a, const Matrax& b, const int mod){
    Matrax ans(a.n, b.m);
    for (int i = 0; i < a.n; i++){
        for (int j = 0; j < b.m; j++){
            int64 tmp = 0;
            for (int k = 0; k < a.m; k++){
                tmp += (a.mat[i][k] * b.mat[k][j]) % mod;
            }
            ans.mat[i][j] = tmp % mod;
        }
    }
    return ans;
}

Matrax pow_mod(const Matrax& a, int64 k, const int mod){
    Matrax p(a.n, a.m), ans(a.n, a.m);
    p = a; ans.Unit(a.n);
    if (k==0) return ans;
    else if (k==1) return a;
    else {
        while (k){
            if (k & 1){
                ans = mul_mod(ans, p, mod);
                k--;
            }
            else {
                k /= 2;
                p = mul_mod(p, p, mod);
            }
        }
        return ans;
    }
}

int64 x, y, n, res;

void solve(){
    cin >> x >> y >> n;
    if (n == 1) res = x;
    else if (n == 2) res = y;
    else
    {
        Matrax ans(2, 1);

        //tmp = cef ^ (n - 2);
        //ans = tmp * beg;
        //res = ans.mat[0][0];

        Matrax cef(2, 2);
        cef.mat[0][0] = 1; cef.mat[0][1] = -1;
        cef.mat[1][0] = 1; cef.mat[1][1] =  0;
        //cef.print();

        Matrax beg(2, 1);
        beg.mat[0][0] = y; beg.mat[1][0] = x;

        Matrax tmp(2, 2);
        tmp = pow_mod(cef, n - 2, Mod);
        //tmp.print();

        ans = mul_mod(tmp, beg, Mod);
        //ans.print();
        res = ans.mat[0][0];
    }
    if (res < 0) res += Mod;
    cout << res << endl;
}

int main()
{
    solve();
    return 0;
}{% endhighlight %}

C. Jzzhu and Chocolate

好逗的题目。就是一个网格状的物品，n行m列，笔直直的切k刀，问所有的可能性中，最大的，每次切出来的结果最小的块的大小。

自己瞎贪心跪了。赛后发现其实可以枚举可能的在行这个方向切得刀数r，计算列方向切的刀数o，然后更新答案的方法。当然，枚举的时候也是只枚举因数，这样就可以把复杂度从O(N)降到O( sqrt(N) )。中间在加上一些优化，然后就没事了。

{% highlight cpp %}
/******************************************************************************
*       COPYRIGHT NOTICE
*       Copyright (c) 2014 All rights reserved
*       ----Stay Hungry Stay Foolish----
*
* @author		:Shen
* @name         :C
* @file         :G:My Source Code[ACM] 比赛719 - CFC.cpp
* @date         :2014/07/19 20:57
* @algorithm    :Greedy
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;
template<class T>inline bool updateMin(T& a, T b){ return a > b ? a = b, 1 : 0; }
template<class T>inline bool updateMax(T& a, T b){ return a < b ? a = b, 1 : 0; }

typedef long long int64;

int64 n, m, k, ans;

int64 run()
{
    if (n - 1 + m - 1 < k) ans = -1;
	for (int64 i = 1; i <= n; i++)
    {
		int64 r = n / (n / i); i = r;
		if (k - (r - 1) > m - 1) continue;
		int64 o = max(k - (r - 1) + 1, 1LL);
		updateMax(ans, 1LL * (n / r) * (m / o));
	}
    return ans;
}

int main()
{
    cin >> n >> m >> k;
    cout << run() << endl;
    return 0;
}{% endhighlight %}
