---
layout: post
title: "[比赛记录] Codeforces Round #256 (Div. 2)"
date: 2014-07-18 00:07:02 +0800
categories: contest solution
tags: codeforces
---

# A. Rewards

水题，但是我看了半天才发现。。。

可能有个陷阱，就是恰巧是5的倍数或者10的倍数的时候是不需要+1处理的。

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :A
#       @file         :A.cpp
#       @date         :2014/07/17 22:00
#       @algorithm    :Easy
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;

int a1, a2, a3;
int b1, b2, b3;
int n;

int main()
{
    cin >> a1 >> a2 >> a3;
    cin >> b1 >> b2 >> b3;
    cin >> n;
    int sa = a1 + a2 + a3; sa = (sa % 5 == 0)? sa / 5: sa / 5 + 1;
    int sb = b1 + b2 + b3; sb = (sb % 10 == 0)? sb / 10: sb / 10 + 1;
    if (sa + sb > n) puts("NO");
    else puts("YES");
    return 0;
}{% endhighlight %}

# D. Multiplication Table

题目意思是，从一个n*m的乘法表（不要问我乘法表是什么）中选出第k小数（相同的数字会计算多次）。

比如样例 2 3 4

乘法表为

1 2 3

2 3 4

非减序列是：1, 2, 2, 3, 3, 4。第4个数字是3，所以输出3。

一开始我想到的是搜索，从n*m开始搜索，后来发现状态实在太多而且即便是搜索，时间复杂度是O(N * M)。

正确的解法是二分。二分答案（边界是[1, n * m]），然后在乘法表中去找比他小的数。因为乘法表是一个有规律的数表，所以针对每一列直接O(1)计算即可，总共计算N次。

总的时间复杂度是O(N * 2 * log(N))。

Code Here
{% highlight cpp %}

/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :D
#       @file         :D.cpp
#       @date         :2014/07/17 22:47
#       @algorithm    :Binary Search
******************************************************************************/

//#pragma GCC optimize ("O2")
//#pragma comment(linker, "/STACK:1024000000,1024000000")

#include <bits/stdc++.h>
using namespace std;
template<class T>inline bool updateMin(T& a, T b){ return a > b ? a = b, 1: 0; }
template<class T>inline bool updateMax(T& a, T b){ return a < b ? a = b, 1: 0; }

typedef long long int64;

int64 n, m, k;

bool check(int64 x)
{
    int64 res = 0;
    for (int i = 1; i <= n; i++)
    {
        int64 tmp = min(i * m, x);
        res += tmp / i;
    }
    return res < k;
}

// 从小往大 计数，第k个
int64 BinarySearch(int64 l, int64 r)
{
    while (l < r)
    {
        int64 mid = (l + r) / 2;
        //cout << l << " " << mid << " " << r << endl;
        //cout << "check result: " << check(mid);
        if (check(mid)) l = mid + 1;
        else r = mid;
        //system("pause");
    }
    return r;
}

int main()
{
    cin >> n >> m >> k;
    int64 Right = n * m, Left = 1;
    int64 ans = BinarySearch(Left, Right);
    cout << ans;
    return 0;
}{% endhighlight %}
