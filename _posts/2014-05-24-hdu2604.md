---
layout: post
title: "HDU 2604 Queuing 矩阵快速幂"
date: 2014-05-24 00:21:41 +0800
categories: contest math
tags: acmicpc hdu mqmod
---
题目地址<a title="HDU 2604" href="http://acm.hdu.edu.cn/showproblem.php?pid=2604" target="_blank">-></a>

突然发现这类题目又是有一个小技巧的。先说题意，一个字符串，由f和m两种字符构成。现在的问题是，其中的子串，不出现“fff”和"fmf"的长度为L的串有多少个。

同样的，我们考虑一个充分长的串，确定他的最后两位之后，看看倒数第三位的字符是什么

这里的x代表的是倒数第三位，可以看到，其实这个是有规律可循的。我们只要把生成fff和fmf的那种情况规避掉就行了。所以整个矩阵就是：

最后把矩阵中的所有的值全部加起来取模即可。

Code Here
{% highlight cpp %}
/****
	*@author    Shen
	*@title     HDU 2604
	*/
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long int64;

const int MAXN = 4;
const int MAXM = 4;
const int Mod = 1000000007;

struct Matrax{
    int n, m;
    int64 mat[MAXN][MAXM];
    Matrax(): n(-1), m(-1){}
    Matrax(int _n, int _m): n(_n), m(_m){
        memset(mat, 0, sizeof(mat));
    }
    void Unit(int _s){
        n = _s; m = _s;
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n; j++){
                mat[i][j] = (i == j)? 1: 0;
            }
        }
    }
    void print(){
        printf("n = %d, m =  %dn", n, m);
        for (int i = 0; i < n; i++){
            for (int j = 0; j < m; j++)
                printf("%16d", mat[i][j]);
            printf("n");
        }
    }
};

Matrax add_mod(const Matrax& a,const Matrax& b,const int64 mod){
    Matrax ans(a.n, a.m);
    for (int i = 0; i < a.n; i++){
        for (int j = 0; j < a.m; j++){
            ans.mat[i][j] = (a.mat[i][j] + b.mat[i][j]) % mod;
        }
    }
    return ans;
}

Matrax mul(const Matrax& a,const Matrax& b){
    Matrax ans(a.n, b.m);
    for (int i = 0; i < a.n; i++){
        for (int j = 0; j < b.m; j++){
            int64 tmp = 0;
            for (int k = 0; k < a.m; k++){
                tmp += a.mat[i][k] * b.mat[k][j];
            }
            ans.mat[i][j] = tmp;
        }
    }
    return ans;
}

Matrax mul_mod(const Matrax& a, const Matrax& b, const int mod){
    Matrax ans(a.n, b.m);
    for (int i = 0; i < a.n; i++){
        for (int j = 0; j < b.m; j++){
            int64 tmp = 0;
            for (int k = 0; k < a.m; k++){
                tmp += (a.mat[i][k] * b.mat[k][j]) % mod;
            }
            ans.mat[i][j] = tmp % mod;
        }
    }
    return ans;
}

Matrax pow_mod(const Matrax& a, int64 k, const int mod){
    Matrax p(a.n, a.m), ans(a.n, a.m);
    p = a; ans.Unit(a.n);
    if (k == 0) return ans;
    else if (k == 1) return a;
    else {
        while (k){
            if (k & 1){
                ans = mul_mod(ans, p, mod);
                k--;
            }
            else {
                k /= 2;
                p = mul_mod(p, p, mod);
            }
        }
        return ans;
    }
}

int  l, m;

void solve(){
    if (l <= 2)
    {
        int root = 1;
        for (int i = 0; i < l; i++)
            root *= 2;
        cout << root % m << endl;
        return;
    }

    Matrax ans(1, 1);

    //tmp = cef ^ (l - 2);
    //ans = vct * tmp;
    //ans = ans * beg;
    //res = ans.mat[0][0] % m;

    Matrax cef(4, 4), tmp(4, 4);
    cef.mat[0][0] = 1; cef.mat[0][3] = 1;
    cef.mat[1][2] = 1;
    cef.mat[2][0] = 1;
    cef.mat[3][1] = 1; cef.mat[3][2] = 1;
    //cef.print();

    Matrax beg(4, 1), vct(1, 4);
    for (int i = 0; i < 4; i++)
        beg.mat[i][0] = vct.mat[0][i] = 1;

    tmp = pow_mod(cef, l - 2, m);
    //tmp.print();

    vct = mul_mod(vct, tmp, m);
    ans = mul_mod(vct, beg, m);
    //ans.print();

    int res = ans.mat[0][0];
    cout << res % m << endl;
}

int main(){
    while (cin >> l >> m) solve();
    return 0;
}{% endhighlight %}
