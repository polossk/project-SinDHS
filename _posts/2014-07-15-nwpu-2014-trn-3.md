---
layout: post
title: "[NWPU][2014][TRN][3] 搜索Div2"
date: 2014-07-15 16:48:17 +0800
categories: contest solution
tags: poj dfs bfs
---
最近刷题太多，一题一题的都写博客太麻烦了，索性写成一个集合贴了。[<a href="http://vjudge.net/contest/view.action?cid=49557#overview" target="_blank">Portal</a>]

广搜深搜的概念太基础了，就不多提了。简单说下这些题目的问题可能出在哪里。

<table width="527">
<tbody>
<tr>
<td width="84">ID</td>
<td width="76">Origin</td>
<td width="163">Title</td>
<td width="204">问题</td>
</tr>
<tr>
<td>Problem A</td>
<td>POJ 3278</td>
<td> 广搜 基础</td>
<td>是否越界</td>
</tr>
<tr>
<td>Problem B</td>
<td>POJ 1979</td>
<td> 广搜/深搜 基础</td>
<td>数据读入，有没有正常清空</td>
</tr>
<tr>
<td>Problem C</td>
<td>POJ 2243</td>
<td> 广搜 基础</td>
<td>是否越过了棋盘</td>
</tr>
<tr>
<td>Problem D</td>
<td>POJ 1915</td>
<td> 广搜 基础</td>
<td>和C题一样</td>
</tr>
<tr>
<td>Problem E</td>
<td>POJ 3984</td>
<td> 广搜记录路径 基础</td>
<td>用一个数组记录前缀</td>
</tr>
<tr>
<td>Problem F</td>
<td>POJ 1111</td>
<td> 广搜 基础</td>
<td>没有难点</td>
</tr>
<tr>
<td>Problem G</td>
<td>POJ 2488</td>
<td> 深搜 基础</td>
<td>注意搜索顺序</td>
</tr>
<tr>
<td>Problem H</td>
<td>POJ 1562</td>
<td> 深搜/广搜 基础</td>
<td>没有难点</td>
</tr>
<tr>
<td>Problem I</td>
<td>POJ 1564</td>
<td> 深搜 基础</td>
<td>标记记录与还原</td>
</tr>
<tr>
<td>Problem J</td>
<td>POJ 3009</td>
<td> 深搜 基础</td>
<td>注意各种情况的处理</td>
</tr>
<tr>
<td>Problem K</td>
<td>POJ 1321</td>
<td> 深搜 基础</td>
<td>没有难点</td>
</tr>
</tbody>
</table>
A

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRN][3] A
#       @file         :A.cpp
#       @date         :2014/07/13 15:02
#       @algorithm    :BFS
******************************************************************************/

//#pragma GCC optimize ("O2")
//#pragma comment(linker, "/STACK:1024000000,1024000000")

#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
using namespace std;
template<class T>inline bool updateMin(T& a, T b){ return a > b ? a = b, 1: 0; }
template<class T>inline bool updateMax(T& a, T b){ return a < b ? a = b, 1: 0; }

typedef long long int64;
int n, k;
int step[100005];
bool vis[100005];
inline bool inbound(int x, int l = 0, int r = 100000) { return l <= x && x <= r; }

inline int newPos(int old, int method)
{
    if (method == 0) return old * 2;
    if (method == 1) return old + 1;
    if (method == 2) return old - 1;
}

int bfs(int beg, int tar)
{
    memset(step, 0, sizeof(step));
    memset(vis, 0, sizeof(vis));
    queue<int> q; q.push(beg); vis[beg] = 1;
    while (!q.empty())
    {
        int top = q.front(); q.pop();
        if (top == tar) break;
        for (int j = 0; j < 3; j++)
        {
            int tmp = newPos(top, j);
            if (inbound(tmp) && !vis[tmp])
            {
                vis[tmp] = 1; step[tmp] = step[top] + 1;
                q.push(tmp);
            }
        }
    }
    return step[tar];
}

int main()
{
    while (cin >> n >> k)
        printf("%dn", bfs(n, k));
    return 0;
}{% endhighlight %}

B

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRN][3] B
#       @file         :B.cpp
#       @date         :2014/07/13 15:13
#       @algorithm    :DFS
******************************************************************************/

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long int64;
int w, h, cnt;
char gird[25][25];
//driection u,  d,  r,  l;
int dx[4] = { 0,  0,  1, -1};
int dy[4] = {-1,  1,  0,  0};

inline bool inbound(int l, int r, int x)
{
    return (x >= l && x < r);
}

inline bool check(int x, int y)
{
    return inbound(0, w, x) && inbound(0, h, y);
}

void dfs(int x, int y)
{
    if (!check(x, y)) return;
    else if (gird[x][y] == '@' || gird[x][y] == '.')
    {
        cnt++;
        gird[x][y] = '#';
        for (int i = 0; i < 4; i++)
            dfs(x + dx[i], y + dy[i]);
    }
}

void solve()
{
    memset(gird, 0, sizeof(gird));
    int sx = 0, sy = 0; cnt = 0;
    for (int i = 0; i < h; i++)
    for (int j = 0; j < w; j++)
    {
        scanf(" %c", &gird[j][i]);
        if (gird[j][i] == '@') sx = j, sy = i;
    }
    dfs(sx, sy);
    printf("%dn", cnt);
}

int main()
{
    while (~scanf("%d%d", &w, &h) && w && h)
        solve();
    return 0;
}{% endhighlight %}

C

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRN][3] C
#       @file         :C.cpp
#       @date         :2014/07/13 15:13
#       @algorithm    :BFS
******************************************************************************/

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <string>
#include <cstdio>
#include <queue>
#include <stack>
#include <algorithm>
using namespace std;

int dx[] = { 1,  2,  2,  1, -1, -2, -2, -1};
int dy[] = { 2,  1, -1, -2, -2, -1,  1,  2};
int step[8][8], fa[8][8];
bool vis[8][8];

inline bool inbound(int x, int l, int r) { return l <= x && x < r; }

inline bool inbound(int u)
{
    int x = u / 8, y = u % 8;
    return inbound(x, 0, 8) && inbound(y, 0, 8);
}

inline int encode(int x, int y) { return x * 8 + y; }

inline int newPos(int old, int method)
{
    int x = old / 8, y = old % 8;
    x += dx[method], y += dy[method];
    if (inbound(x, 0, 8) && inbound(y, 0, 8)) return encode(x, y);
    else return -1;
}

inline int getx(string s) { return int(s[0] - 'a'); }

inline int gety(string s) { return int(s[1] - '1'); }

int bfs(string _beg, string _tar)
{
    int beg = encode(getx(_beg), gety(_beg));
    int tar = encode(getx(_tar), gety(_tar));
    memset(step, 0, sizeof(step));
    memset(vis, 0, sizeof(vis));
    memset(fa, 0, sizeof(fa));
    queue<int> q; q.push(beg); vis[beg / 8][beg % 8] = 1;
    fa[beg / 8][beg % 8] = beg;
    while (!q.empty())
    {
        //bprint();
        int top = q.front(); q.pop();
        if (top == tar) break;
        for (int j = 0; j < 8; j++)
        {
            int tmp = newPos(top, j);
            if (tmp != -1 && inbound(tmp) && !vis[tmp / 8][tmp % 8])
            {
                vis[tmp / 8][tmp % 8] = 1;
                step[tmp / 8][tmp % 8] = step[top / 8][top % 8] + 1;
                fa[tmp / 8][tmp % 8] = top;
                q.push(tmp);
            }
        }
    }
    return step[tar / 8][tar % 8];
}

int main()
{
    string b, t;
    while (cin >> b >> t)
        printf("To get from %s to %s takes %d knight moves.n", b.c_str(), t.c_str(), bfs(b, t));
    return 0;
}{% endhighlight %}

D

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRN][3] D
#       @file         :D.cpp
#       @date         :2014/07/14 16:44
#       @algorithm    :BFS
******************************************************************************/

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <string>
#include <cstdio>
#include <queue>
#include <stack>
#include <algorithm>
using namespace std;

int dx[] = { 1,  2,  2,  1, -1, -2, -2, -1};
int dy[] = { 2,  1, -1, -2, -2, -1,  1,  2};
const int MaxL = 310;
int step[MaxL][MaxL];
bool vis[MaxL][MaxL];

int t, l, nx, ny, fx, fy;

inline bool inbound(int x, int l, int r) { return l <= x && x < r; }

inline bool inbound(int u, int size = l)
{
    int x = u / size, y = u % size;
    return inbound(x, 0, size) && inbound(y, 0, size);
}

inline int encode(int x, int y, int size = l) { return x * size + y; }

inline int newPos(int old, int method, int size = l)
{
    int x = old / size, y = old % size;
    x += dx[method], y += dy[method];
    if (inbound(x, 0, size) && inbound(y, 0, size)) return encode(x, y);
    else return -1;
}

int bfs(int beg, int tar, int size = l)
{
    memset(step, 0, sizeof(step));
    memset(vis, 0, sizeof(vis));
    queue<int> q; q.push(beg);
    vis[beg / size][beg % size] = 1;
    while (!q.empty())
    {
        int top = q.front(); q.pop();
        if (top == tar) break;
        for (int j = 0; j < 8; j++)
        {
            int tmp = newPos(top, j);
            if (tmp != -1 && inbound(tmp) && !vis[tmp / size][tmp % size])
            {
                vis[tmp / size][tmp % size] = 1;
                step[tmp / size][tmp % size] = step[top / size][top % size] + 1;
                q.push(tmp);
            }
        }
    }
    return step[tar / size][tar % size];
}

int main()
{
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d%d%d%d%d", &l, &nx, &ny, &fx, &fy);
        int beg = encode(nx, ny);
        int tar = encode(fx, fy);
        printf("%dn", bfs(beg, tar));
    }
    return 0;
}{% endhighlight %}

E

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRN][3] E
#       @file         :E.cpp
#       @date         :2014/07/14 16:44
#       @algorithm    :BFS
******************************************************************************/

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <string>
#include <cstdio>
#include <queue>
#include <stack>
#include <algorithm>
using namespace std;

int dx[] = { 1, -1,  0,  0};
int dy[] = { 0,  0,  1, -1};

const int MaxL = 6;
int fa[MaxL][MaxL];
bool vis[MaxL][MaxL];
bool grid[MaxL][MaxL];

inline bool inbound(int x, int l, int r) { return l <= x && x < r; }

inline bool inbound(int u)
{
    int x = u / 5, y = u % 5;
    return !grid[x][y] && inbound(x, 0, 5) && inbound(y, 0, 5);
}

inline int encode(int x, int y) { return x * 5 + y; }

inline int newPos(int old, int method)
{
    int x = old / 5, y = old % 5;
    x += dx[method], y += dy[method];
    if (inbound(x, 0, 5) && inbound(y, 0, 5)) return encode(x, y);
    else return -1;
}

bool bfs(int beg, int tar)
{
    memset(fa, 0, sizeof(fa));
    memset(vis, 0, sizeof(vis));
    queue<int> q; q.push(beg);
    vis[beg / 5][beg % 5] = 1;
    fa[beg / 5][beg % 5] = 0;
    while (!q.empty())
    {
        int top = q.front(); q.pop();
        if (top == tar) break;
        for (int j = 0; j < 4; j++)
        {
            int tmp = newPos(top, j);
            if (tmp != -1 && inbound(tmp) && !vis[tmp / 5][tmp % 5])
            {
                vis[tmp / 5][tmp % 5] = 1;
                fa[tmp / 5][tmp % 5] = top;
                q.push(tmp);
            }
        }
    }
    return false;
}

void path_print(int tar)
{
    int nx = tar / 5, ny = tar % 5;
    int fn = fa[nx][ny];
    int fx = fn / 5, fy = fn % 5;
    if (fx != nx || fy != ny)
    {
        path_print(encode(fx, fy));
        printf("(%d, %d)n", nx, ny);
    }
}

int main()
{
    for (int i = 0; i < 5; i++)
        for (int j = 0; j < 5; j++)
            cin >> grid[i][j];
    int beg = encode(0, 0), tar = encode(4, 4);
    puts("(0, 0)");
    bfs(beg, tar);
    path_print(tar);
    return 0;
}{% endhighlight %}

F

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRN][3] F
#       @file         :F.cpp
#       @date         :2014/07/14 21:04
#       @algorithm    :DFS
******************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
using namespace std;

const int MaxL = 105;
char grid[MaxL][MaxL];
bool vis[MaxL][MaxL];
int sum, r, c, x, y;
int dx[] = { 0,  0, -1, -1, -1,  1,  1,  1};
int dy[] = { 1, -1,  1,  0, -1,  1,  0, -1};

inline bool inbound(int x, int l, int r) { return l <= x && x < r; }


void dfs(int a, int b)
{
    vis[a][b] = 1;
    for (int i = 0; i < 8; i++)
    {
        int x = a + dx[i], y = b + dy[i];
        if (inbound(x, 0, r) && inbound(y, 0, c))
        {
            if (grid[x][y] == 'X' && vis[x][y] == 0) dfs(x, y);
            else if (grid[x][y] == '.' && ((x == a) || (y == b))) sum++;
        }
        else if (x == a || y == b) sum++;
    }
}

void solve()
{
    memset(vis, 0, sizeof(vis));
    for (int i = 0; i < r; i++)
        for (int j = 0; j < c; j++)
            scanf(" %c", &grid[i][j]);
    sum = 0; dfs(x - 1, y - 1);
    printf("%dn", sum);
}

int main()
{
    while(~scanf("%d%d%d%d", &r, &c, &x, &y) && r && c && x && y)
        solve();
    return 0;
}{% endhighlight %}

G

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRN][3] G
#       @file         :G.cpp
#       @date         :2014/07/14 17:41
#       @algorithm    :DFS
******************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
using namespace std;

int t, tt, a, b;
int vis[27][27];
pair<int, int> path[27];
bool flag = 0;

inline bool inbound(int x, int l, int r) { return l <= x && x < r; }

inline int encode(int x, int y) { return a * x + y; }

void dfs(int x, int y, int n)
{
	if (!flag && vis[x][y] == 0
		&& inbound(x, 0, a) && inbound(y, 0, b)
		&& n <= a * b)
	{
		vis[x][y] = n;
        path[n] = make_pair(x, y);
		n++;
		if (n > a * b) flag = 1;
		dfs(x - 2, y - 1, n);
		dfs(x - 2, y + 1, n);
		dfs(x - 1, y - 2, n);
		dfs(x - 1, y + 2, n);
		dfs(x + 1, y - 2, n);
		dfs(x + 1, y + 2, n);
		dfs(x + 2, y - 1, n);
		dfs(x + 2, y + 1, n);
		vis[x][y] = 0;
	}
	else return;
}

int main()
{
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d%d", &b, &a);
        memset(vis, 0, sizeof(vis));
        printf("Scenario #%d:n", ++tt);
        flag = 0; dfs(0, 0, 1);
        if (flag)
        {
            for (int i = 1; i <= a * b; i++)
                printf("%c%d", 'A' + path[i].first, path[i].second + 1);
            puts("");
        }
        else puts("impossible");
        if (t != 0) puts("");
    }
	return 0;
}{% endhighlight %}

H

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRN][3] H
#       @file         :H.cpp
#       @date         :2014/07/14 21:04
#       @algorithm    :DFS
******************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
using namespace std;

const int MaxL = 105;
char grid[MaxL][MaxL];
int sum, m, n;
int dx[] = { 0,  0, -1, -1, -1,  1,  1,  1};
int dy[] = { 1, -1,  1,  0, -1,  1,  0, -1};

inline bool inbound(int x, int l, int r) { return l <= x && x < r; }


void dfs(int x, int y)
{
    if (inbound(x, 0, m) && inbound(y, 0, n) && grid[x][y] == '@')
    {
        grid[x][y] = '*';
        for (int i = 0; i < 8; i++)
        {
            int a = x + dx[i], b = y + dy[i];
            dfs(a, b);
        }
    }
}

void solve()
{
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            scanf(" %c", &grid[i][j]);
    sum = 0;
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            if (grid[i][j] == '@')
    {
        dfs(i, j);
        sum++;
    }
    printf("%dn", sum);
}

int main()
{
    while(~scanf("%d%d", &m, &n) && m && n)
        solve();
    return 0;
}{% endhighlight %}

I

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRN][3] I
#       @file         :I.cpp
#       @date         :2014/07/15 12:10
#       @algorithm    :DFS
******************************************************************************/

#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
using namespace std;

const int MaxL = 1005;
int num[MaxL], ans[MaxL];
bool flag;
int vis, step, m, n;

void dfs(int x, int cnt)
{
	if (cnt > n) return;
	else if (cnt == n)
	{
		flag = true;
		printf("%d", ans[1]);
		for (int i = 2; i < step; i++)
			printf("+%d", ans[i]);
		puts(""); return;
	}
	int vis = -1;
	for (int j = x + 1; j <= m; j++)
	{
		if (num[j] != vis)
		{
			ans[step++] = num[j];
			vis = num[j];
			dfs(j, cnt + num[j]);
			step--;
		}
	}
}

void solve()
{
	flag = false;
	step = 1;
	memset(num, 0, sizeof(num));
	memset(ans, 0, sizeof(ans));
	for (int i = 1; i <= m; i++)
		scanf("%d", &num[i]);
	printf("Sums of %d:n", n);
	dfs(0, 0);
	if (!flag) printf("NONEn");
}

int main()
{
    while(~scanf("%d%d", &n, &m) && m && n)
        solve();
    return 0;
}{% endhighlight %}

J

{% highlight cpp %}
/******************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRN][3] J
#       @file         :G:My Source Code[ACM] 训练712 - [NWPU][2014][TRN][3]J.cpp
#       @date         :2014/7/15 13:42
#       @algorithm    :DFS
******************************************************************************/

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long int64;
int w, h, res;
int gird[25][25];
//driection   u,  d,  r,  l;
int dx[4] = { 0, 0, 1, -1 };
int dy[4] = { -1, 1, 0, 0 };

inline bool inbound(int l, int r, int x)
{
	return (x >= l && x < r);
}

inline bool check(int x, int y)
{
	return inbound(0, w, x) && inbound(0, h, y);
}

void dfs(int cnt, int x, int y)
{
	int cx = 0, cy = 0;
	bool flag = false;
	if (cnt > 10) return;
	for (int i = 0; i < 4; i++)
	{
		flag = false;
		if (gird[x + dx[i]][y + dy[i]] == 1)
			continue;
		cx = x, cy = y;
		while (1)
		{
			cx += dx[i], cy += dy[i];
			if (!check(cx, cy)) break;
			if (gird[cx][cy] == 1) { flag = true; break; }
			if (gird[cx][cy] == 3) { res = min(res, cnt); break; }
		}
		if (flag)
		{
			gird[cx][cy] = 0;
			dfs(cnt + 1, cx - dx[i], cy - dy[i]);
			gird[cx][cy] = 1;
		}
	}
}

void solve()
{
	memset(gird, 0, sizeof(gird));
	res = 11;
	int sx = 0, sy = 0;
	for (int i = 0; i < h; i++)
		for (int j = 0; j < w; j++)
		{
			scanf(" %d", &gird[j][i]);
			if (gird[j][i] == 2) sx = j, sy = i;
		}
	dfs(1, sx, sy);
	if (res > 10)   printf("-1n");
	else            printf("%dn", res);
}

int main()
{
	while (scanf("%d%d", &w, &h))
	{
		if (w == 0 && h == 0) break;
		else solve();
	}
	return 0;
}{% endhighlight %}

K

{% highlight cpp %}
/******************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][2014][TRN][3] K
#       @file         :G:My Source Code[ACM] 训练712 - [NWPU][2014][TRN][3]K.cpp
#       @date         :2014/7/15 13:46
#       @algorithm    :DFS
******************************************************************************/

#define _CRT_SECURE_NO_WARNINGS

#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <algorithm>
using namespace std;

const int MaxL = 13;
int cnt, n, k;
char grid[MaxL][MaxL];
bool vis[MaxL];

void dfs(int x, int cur)
{
	if (cur == k) { cnt++; return; }
	else
	{
		for (int i = x; i < n; i++)
			for (int j = 0; j < n; j++)
				if (grid[i][j] == '#' && !vis[j])
				{
					vis[j] = 1;
					dfs(i + 1, cur + 1);
					vis[j] = 0;
				}
	}
}

void solve()
{
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			scanf(" %c", &grid[i][j]);
	cnt = 0;
	memset(vis, 0, sizeof(vis));
	dfs(0, 0);
	printf("%dn", cnt);
}

int main()
{
	while (scanf("%d%d", &n, &k))
	{
		if (n == -1 && k == -1) break;
		else solve();
	}
	return 0;
}{% endhighlight %}
