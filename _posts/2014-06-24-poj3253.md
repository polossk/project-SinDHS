---
layout: post
title: "POJ 3253 Fence Repair 类似哈夫曼树的贪心思想"
date: 2014-06-24 17:22:16 +0800
categories: contest algorithm
tags: acmicpc poj greedy
---
题目地址<a title="POJ 3253" href="http://poj.org/problem?id=3253" target="_blank">-></a>

用类似哈夫曼树的思想去考虑，每次选取两个较小的点合并，然后把合并后的放回原集合。用一个小根堆去维护即可。

注意首先，C++的优先队列默认是大顶堆，所以需要改写；其次，改写之后的堆是没有clear()方法的，所以务必记住队列的清空！

Code Here
{% highlight cpp %}
/**============================================================================
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :POJ 3253
#       @file         :G:My Source Code[ACM] 训练624 - 基础poj3253.cpp
#       @date         :2014-06-24 14:45
#       @algorithm    :Greedy
============================================================================**/

//#pragma GCC optimize ("O2")
//#pragma comment(linker, "/STACK:1024000000,1024000000")

#include <queue>
#include <cstdio>
#include <string>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <algorithm>
using namespace std;
template<class T>inline bool updateMin(T& a, T b){ return a > b ? a = b, 1: 0; }
template<class T>inline bool updateMax(T& a, T b){ return a < b ? a = b, 1: 0; }

typedef long long int64;

int n, l;

void solve()
{
    priority_queue<int, vector<int>, greater<int> > pq;
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &l);
        pq.push(l);
    }
    int64 ans = 0;
    if (n == 1) ans = l;
    while (pq.size() > 1)
    {
        int a = pq.top(); pq.pop();
        int b = pq.top(); pq.pop();
        int c = a + b;
        ans += c; pq.push(c);
    }
    printf("%dn", ans);
}

int main()
{
    while (~scanf("%d", &n)) solve();
    return 0;
}{% endhighlight %}
