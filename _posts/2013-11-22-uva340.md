---
layout: post
title: "UVa 340 Master-Mind Hints 数字匹配"
date: 2013-11-22 21:00:02 +0800
categories: contest serach
tags: acmicpc uva basicsearch
---
题目地址<a title="UVa 340" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=98&page=show_problem&problem=276" target="_blank">-></a>

题目的意思是玩一个猜数字序列的游戏，位置和数字都正确就是题目中的strong，位置不正确但是数字正确就是weak，类似于以前玩各的一个几A几B的游戏。由于N实在是太小了，N<=1000，所以完全可以在朴素匹配的时间内将答案计算出来。所以说，就不再对代码进行过多的说明了，朴素匹配即可。

Code Here
{% highlight cpp %}
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;

const int maxN = 1005;
int codeorigin[maxN], guess[maxN], code[maxN];
int st, wk;

void read(int n){
    for (int i = 0; i < n; ++i){
        scanf("%d", &codeorigin[i]);
    }
}

void cal(int n){
    while (1){
        st = wk = 0;
        int zeroflag = 0;
        for (int i = 0; i < n; ++i){
            scanf("%d", &guess[i]);
            if (guess[i] == 0)++zeroflag;
            if (guess[i] == codeorigin[i]){
                ++st;
                code[i] = -1;
                guess[i] = -1;
            }
            else code[i] = codeorigin[i];
        }
        if (zeroflag == n)return;
        for (int i = 0; i < n; ++i){
            if (guess[i] != -1){
                for (int j = 0; j < n; ++j){
                    if (guess[i] == code[j]){
                        ++wk;
                        code[j] = -1;
                        guess[i] = -1;
                        break;
                    }
                }
            }
        }
        printf("    (%d,%d)n", st, wk);
    }
}

void solve(int casenum, int n){
    read(n);
    printf("Game %d:n", casenum);
    cal(n);
}

int main(){
    int casenum = 0;
    int n;
    while (scanf("%d", &n) && n){
        solve(++casenum, n);
    }
    return 0;
}{% endhighlight %}
