---
layout: post
title:  "LightOJ 1067 又是一发组合数求模"
date:   2013-08-14 22:36:00 +0800
categories: contest math
tags: acmicpc lightoj combination cmod
---

题目地址[->](http://www.lightoj.com/volume_showproblem.php?problem=1067)

题目大意是说：m个相同的球放到n个盒子里 C(m+n-1,m)。

现在就需要求不大于m的，相当于对i = 0,1...,m的C(n+i-1,i)求和。

{% highlight plain %}
C(n,k) = C(n-1,k)+C(n-1,k-1)
C(n-1,0)+C(n,1)+...+C(n+m-1,m)
= C(n,0)+C(n,1)+C(n+1,2)+...+C(n+m-1,m)
= C(n+m,m)
{% endhighlight %}

现在就是要求C(n+m,m) % p,其中p是素数

同样，本题仍然需要用到Lucas定理来计算，虽然实际并没有调用，这里是一个较为简单的介绍[[传送门]({% post_url 2013-08-14-lightoj1102 %})]

# Code Here
{% highlight cpp %}
/****
	*@Polo-shen
	*
	*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
typedef long long int64;

using namespace std;
const int64 MOD=1000003;
const int64 MAXN=1000010;
int64 N,M;
class Combinations_Mod_without_Lucas{
//将所有用到的函数封装进这个类中
public:
	int64 fac[MAXN];//阶乘数组
	//快速乘法取模，计算a*b mod m
	int64 q_mul_mod(int64 a,int64 b,int64 m){
		a%=m;
		b%=m;
		int64 t=0;
		while (b){
			if (b&1){
				t+=a;
				if (t>=m)
					t-=m;
			}
			a<<=1;
			if (a>=m)a-=m;
			b>>=1;
		}
		return t;
	}
	//预处理阶乘
	void facterial(){
		fac[0]=1;
		for (int i=1;i<MAXN;i++){
			fac[i]=fac[i-1]*i%MOD;
		}
	}
	//快速乘方取模，计算a^b mod m
	int64 q_pow_mod(int64 a,int64 b,int64 m){
		int64 ans=1;
		a%=m;
		while (b){
			if (b&1){
				ans=q_mul_mod(ans,a,m);
				b--;
			}
			b/=2;
			a=q_mul_mod(a,a,m);
		}
		return ans;
	}
	//扩展欧几里得，返回值为gcd(a,b)
	//gcd(a,b)=a*x+b*y
	int64 gcd_ex(int64 a,int64 b,int64& x,int64& y){
		if (b==0){
			x=1;
			y=0;
			return a;
		}
		int64 d=gcd_ex(b,a%b,x,y);
		int64 t=x;
		x=y;
		y=t-a/b*y;
		return d;
	}
	int64 cal(int64 n,int64 mod){
		int64 x,y;
		int64 t=gcd_ex(n,mod,x,y);
		return (x%mod+mod)%mod;
	}
	//一般的组合数公式
	int64 C(int64 n,int64 m){
		return fac[n]*cal(fac[m],MOD)*cal(fac[n-m],MOD)%MOD;
	}
	//Lucas方法
	int64 Lucas(int64 n,int64 m){
		if (m==0){
			return 1;
		}
		return q_mul_mod(C(n%MOD,m%MOD),Lucas(n/MOD,m/MOD),MOD);
	}
}cm;//cm是这个类的一个实例

//本题的主要求解
int64 solve(int64 n,int64 m){
	if (m==0)
		return 1;
	else return cm.C(n,m);
}

int main (){
	int T,tt=1;
	int64 n,m;cm.facterial();
	cin>>T;
	while (T--){
		cin>>n>>m;
		int64 ans;
		ans=solve(n,m);
		cout<<"Case "<<tt++<<": "<<ans<<endl;
	}
	return 0;
}
{% endhighlight %}