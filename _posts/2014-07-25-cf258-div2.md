---
layout: post
title: "[比赛记录] Codeforces Round #258 (Div. 2)"
date: 2014-07-25 02:33:30 +0800
categories: contest solution
tags: codeforces
---
逗比的A题WA了一发，B题细节处理半天最后fst了。。。C题也fst了，因为忘了数据是int64...，还好D题过了，要不然就傻逼到家了。

# A. Game With Sticks

不要问我为何会WA一发！不要问我！

就是每次横竖两行少两个，看谁先没得拿。
{% highlight cpp %}
// <!--encoding UTF-8 UTF-8编码--!>
/*****************************************************************************
*----Stay Hungry Stay Foolish----
*@author:	Shen
*@name	:	A
******************************************************************************/

//#pragma GCC optimize ("O2")
//#pragma comment(linker, "/STACK:1024000000,1024000000")

#include <bits/stdc++.h>
using namespace std;
template<class T>inline bool updateMin(T& a, T b){ return a > b ? a = b, 1: 0; }
template<class T>inline bool updateMax(T& a, T b){ return a < b ? a = b, 1: 0; }

typedef long long int64;

int n, m;
const string w = "Akshat";
const string l = "Malvika";

int main()
{
    while (cin >> n >> m)
    {
        int c = min(n, m);
        if (c % 2) cout << w << endl;
        else cout << l << endl;
    }
    return 0;
}{% endhighlight %}

# B. Sort the Array

不要问我为何fst了！因为我的智商在统计有多少个下降区间的时候，处理到m = 2就直接continue了。。。。。。

其实很简单，就是先判断有多少个下降区间。如果有少于2个的这样的区间，就去判断翻转后是否满足增序列的性质即可。

{% highlight cpp %}
// <!--encoding UTF-8 UTF-8编码--!>
/*****************************************************************************
*----Stay Hungry Stay Foolish----
*@author:	Shen
*@name	:	B
******************************************************************************/

//#pragma GCC optimize ("O2")
//#pragma comment(linker, "/STACK:1024000000,1024000000")

#include <bits/stdc++.h>
using namespace std;
template<class T>inline bool updateMin(T& a, T b){ return a > b ? a = b, 1: 0; }
template<class T>inline bool updateMax(T& a, T b){ return a < b ? a = b, 1: 0; }

typedef long long int64;

const int MaxN = 100005;
int n, a[MaxN];
bool inc[MaxN];

inline bool judge(int l, int r)
{
    if (l == 0 && r == n - 1)
        return 1;
    else if (l == 0)
        //cout << a[l] << a[r + 1] << endl;
        return a[l] < a[r + 1];
    else if (r == n - 1)
        //cout << a[l - 1] << a[r] << endl;
        return a[l - 1] < a[r];
    else
        //cout << a[l] << a[r + 1] << a[l - 1] << a[r] << endl;
        return a[l - 1] < a[r] && a[l] < a[r + 1];
    //return 1;
}

void solve()
{
    int l = 0, r = 0;
	int m = 0;
	// 0没有
	// 1有一个
	// 2有多个
	scanf("%d", &a[0]); inc[0] = 0;
	for (int i = 1; i < n; i++)
    {
		scanf("%d", &a[i]);
		inc[i] = (a[i] > a[i - 1]);
		//cout << "m = " << m << ", i = " << i << ", inc[" << i << "] = " << inc[i] << endl;
		if (m >= 2)
        {
            // WA //continue;
            if (!inc[i]) m++;
        }
		else if (m == 1)
        {
            if (!inc[i]) r++;
            else m++;
        }
        else if (m == 0)
        {
            l++; r++;
            if (!inc[i]) m = 1;
        }
    }
    l -= 1;
    //cout << l << " " << r << endl;
    //cout << m << endl;
    if (m == 0) puts("yesn1 1");
    else if (m >= 3) puts("no");
    else if (judge(l, r))
    {
        puts("yes");
        printf("%d %dn", l + 1, r + 1);
    }
    else puts("no");
}

int main()
{
    while (~scanf("%d", &n)) solve();
    return 0;
}{% endhighlight %}

# C. Predict Outcome of the Game

暴力模拟，因为写代码写傻了，中间忘记了int64然后华丽丽的跪了。。。

{% highlight cpp %}
// <!--encoding UTF-8 UTF-8编码--!>
/*****************************************************************************
*----Stay Hungry Stay Foolish----
*@author:	Shen
*@name	:	C
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;
typedef long long int64;

void solve()
{
    int64 n, k, d1, d2;
    bool ans = 0;
    cin >> n >> k >> d1 >> d2;
    if (k < max(d1, d2)) puts("no");
    else
    {
		int64 t1 = k - d1 + d2;
		int64 t2 = k + d1 - d2;
		int64 t3 = k + d1 + d2;
		int64 t4 = k - d1 - d2;
		int64 dmx = max(d1, d2), det = abs(d1 - d2);
        if (t1 % 3 == 0 && t1 / 3 >= d2)
        {
            if ((n -  d1 - t3) >= 0 && (n -  d1 - t3) % 3 == 0)
                ans = 1;
        }
        if (t2 % 3 == 0 && t2 / 3 >= d1)
        {
            if ((n -  d2 - t3) >= 0 && (n -  d2 - t3) % 3 == 0)
                ans = 1;
        }
        if (t4 % 3 == 0 && t4 >= 0)
        {
            int x = t1 / 3;
            if ((n - k - dmx - det) >= 0 && (n - k - dmx - det) % 3 == 0)
                ans = 1;
        }
        if (t3 % 3 == 0 && t3 / 3 - max(d1, d2) >= 0)
        {
            int x = t1 / 3;
            if ((n - t3) >= 0 && (n - t3) % 3 == 0)
                ans = 1;
        }
        if (ans == 1) puts("yes");
        else puts("no");
    }
}

int main()
{
    int t; cin >> t;
    while (t--) solve();
    return 0;
}{% endhighlight %}

# D. Count Good Substrings

从左到右扫一遍，然后计数DP

{% highlight cpp %}
// <!--encoding UTF-8 UTF-8编码--!>
/*****************************************************************************
*----Stay Hungry Stay Foolish----
*@author:	Shen
*@name	:	D
******************************************************************************/

//#pragma GCC optimize ("O2")
//#pragma comment(linker, "/STACK:1024000000,1024000000")

#include <bits/stdc++.h>
using namespace std;
template<class T>inline bool updateMin(T& a, T b){ return a > b ? a = b, 1: 0; }
template<class T>inline bool updateMax(T& a, T b){ return a < b ? a = b, 1: 0; }

typedef long long int64;

const int MaxN = 100005;
char str[MaxN];
int a[7][7];

void solve()
{
    int len = strlen(str + 1);
    int64 x = 0, y = 0;
    for(int i = 1; i <= len; i++)
    {
        a[i & 1][str[i] - 'a']++;
        y += a[i & 1][str[i] - 'a'];
        x += a[!(i & 1)][str[i] - 'a'];
    }
    printf("%I64d %I64dn", x, y);
}

int main()
{
    while (~scanf("%s", str + 1)) solve();
    return 0;
}{% endhighlight %}
