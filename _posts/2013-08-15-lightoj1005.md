---
layout: post
title:  "LightOJ 1005 棋盘摆车问题 组合数"
date:   2013-08-15 19:31:00 +0800
categories: contest math
tags: acmicpc lightoj combination cmod
---

题目地址[->](http://www.lightoj.com/volume_showproblem.php?problem=1005)

题目大意是说在国际象棋的棋盘上摆放“车”这个棋子，给你n和k，n是指n * n大小的棋盘，k是指有多少个棋子，求可以摆放的方案总数。

第一眼看上去题目似乎有些复杂，其关键就在于如何计算答案。

我们不妨设题目中的答案为M(n,k)，n和k分别对应题目中的n和k。同样的，我们仍然从简单的情况分析。

当k>n时，显然不可能摆放所有的棋子，所以此时M(n,k)=0；

所以我们现在只讨论当k小于等于n时的情况。

当k=1时，我们可以在任意一个位置摆放棋子，所以此时M(n,1)=n^2；

当k=2时，首先假设k小于等于n，我们可以这样想，先在棋盘的n竖列中选取两列，随后，只要两个棋子的“高度”不同（把棋盘看作一个坐标系，选取好竖列后相当于确定了其横坐标，下面我们只需要考察纵坐标即可）就可以记作一种可行方案。那么显然，子问题转化为在高度为n的单元格上有n个棋子，其中只有两个棋子是不透明的，其余棋子为透明棋子。问有多少种排列方式。答案很明显是A(n,2)。在考虑到第一步的答案C(n,2)，由分布计数的结论，M(n,2)=A(n,2) * C(n,2)。

我觉得解释到这里就不需要接着解释了，对于一般的M(n,k)，我们有

{% highlight plain %}
M(n,k) = A(n,k) * C(n,k) ;(k>n)
= 0 ;(0<K<=n)
{% endhighlight %}

# Code Here
{% highlight cpp %}
#include <stdio.h>
#include <iostream>
#include <string>

using namespace std;
int main()
{
    int k;
    cin>>k;
    for(int i=0;i<k;i++)
    {
        long long ans=1;
        long long tool=1;
        int m,n;
        cin>>m>>n;
        long long tool2=1;
        for(int j=1;j<=n;j++)
        {
            tool2*=j;
        }
        for(int j=m;j>m-n;j--)
        {
            tool*=j;
        }
        ans=tool/tool2*tool;
        printf("Case %d: %lld\n",i+1,ans);
    }
    return 0;
}
{% endhighlight %}
