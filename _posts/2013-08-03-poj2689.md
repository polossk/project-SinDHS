---
layout: post
title:  "POJ 2689 Prime Distance 素数距离"
date:   2013-08-03 21:56:00 +0800
categories: contest math
tags: acmicpc poj numbertheory primenumber
---
题目地址[->](http://poj.org/problem?id=2689)

直接暴力就行，没有任何难点。

Code Here

{% highlight cpp %}
/****
    *@Polo-shen
    *Memory: 1640K  Time: 32MS
    */
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <cstdio>
#include <string>
using namespace std;
#define Forn(i,st,ed) for(int (i)=(st);(i)<(ed);(i)++)
#define ReForn(i,st,ed) for(int (i)=(st);(i)>(ed);(i)--)
#define Forned(i,st,ed) for(int (i)=(st);(i)<=(ed);(i)++)
#define ReForned(i,st,ed) for(int (i)=(st);(i)>=(ed);(i)--)
#define Repeat(n) for(int iii=0;iii<(n);iii++)
#define Clr(v,val) memset(v,val,sizeof(v))

#define Read(n) cin>>n;
#define print(n) cout<<#n"= "<<(n)<<endl;

//#define max(a,b) ((a)>(b)?(a):(b))
//#define min(a,b) ((a)<(b)?(a):(b))

#define Maxn 50001
#define INF 99999999

typedef long long int64;
typedef __int64 int64;

int prime1[Maxn],nprime1;
bool isprime[Maxn*20];
void make_prime1(){
    int64 i,j;
    nprime1=0;
    Clr(isprime,1);
    for(i=2;i<Maxn;i++){
        if (isprime[i]){
            nprime1++;
            prime1[nprime1]=i;
            for(j=i*i;j<Maxn;j+=i)isprime[j]=0;
        }

    }
}
int64 l,u;
int64 prime2[1000001];
int nprime2;
void make_prime2(){
    int64 i,j,b;
    Clr(isprime,1);
    for(i=1;i<=nprime1;i++){
        b=l/prime1[i];
        while (b*prime1[i]<l || b<=1){
            b++;
        }
        for(j=b*prime1[i];j<=u;j+=prime1[i]){
            if(j>=l){
                isprime[j-l]=0;
            }
        }
    }
    if(l==1){
        isprime[0]=0;
    }
}
void solve(){
    int i;
    int64 min=INF,max=-INF;
    int64 minl,minr,maxl,maxr;
    make_prime2();
    nprime2=0;
    for(i=0;i<=u-l;i++){
        if(isprime[i]){
            nprime2++;
            prime2[nprime2]=i+l;
        }
    }
    if (nprime2<=1){
        cout<<"There are no adjacent primes."<<endl;
    }
    else{
        for (i=1;i<nprime2;i++){
            if (prime2[i+1]-prime2[i]<min){
                min=prime2[i+1]-prime2[i];
                minl=prime2[i];minr=prime2[i+1];
            }
            if (prime2[i+1]-prime2[i]>max){
                max=prime2[i+1]-prime2[i];
                maxl=prime2[i];maxr=prime2[i+1];
            }
        }
        cout<<minl<<","<<minr<<" are closest, ";
        cout<<maxl<<","<<maxr<<" are most distant."<<endl;
    }
}
int main(){
    make_prime1();
    while (cin>>l>>u){
        solve();
    }
    return 0;
}
{% endhighlight %}