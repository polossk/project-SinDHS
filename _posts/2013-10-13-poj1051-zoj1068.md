---
layout: post
title: "POJ 1051 ZOJ 1068 P,MTHBGWB 字符串处理"
date: 2013-10-13 01:52:27 +0800
categories: contest string
tags: acmicpc poj zoj basicstring
---
题目地址（<a title="POJ 1051" href="http://poj.org/problem?id=1051" target="_blank">POJ</a>，<a title="ZOJ 1068" href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1068" target="_blank">ZOJ</a>）

题目的意思有点晦涩，不过其实很好理解。通过我们的观察可以发现摩尔斯电码有一种缺陷，就是因为字母由不同长度的点横来代替，所以，有可能出现很多各式各样的解码错误。比如说本来我想说“SOS”，也就是“...---...”，但是很有可能误解成“EEETTTEEE”，显然，不知所云了。因此有人发明了一种信息的加密方式，分为3个步骤：

<ol>
<li>把目标文本转换为没有停顿的摩尔斯电码，并且额外增加一个数字串A记录每一个编码的长度；</li>
<li>把这个数字串A前后颠倒得到A'；</li>
<li>用颠倒后的数字串A'作为每个编码的长度，再把点横转化为文本；</li>
</ol>
如此一来，相当于规范了一些，至少能够方便传递文本了，或许这是哪个设计者所想到的，反正我不怎么觉得这种编码有什么好处。

好了言归正传，首先你得程序中要有两个部分：电码转明码，明码转电码。随后，在主要的解题函数中（我的代码里就是solve()了）把这套密文明文转换写进去，应该不会有什么大问题，主要还是细心方面的，算是一个比较简单的处理了。具体的请看代码吧。

Code Here

{% highlight cpp %}
/****
	*@Polo-shen
	*
	*/
#include <iostream>
#include <string>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <vector>

using namespace std;
typedef long long int64;

enum {
	A = 'A',B,C,D,E,F,G,
	H,I,J,K,L,M,N,
	O,P,Q,R,S,T,
	U,V,W,X,Y,Z
};


enum {
	underscore = '_',
	period = '.',
	comma = ',',
	questionmark = '?'
};


char morseCode[26][6]={
	".-","-...","-.-.","-..",".","..-.","--.",
	"....","..",".---","-.-",".-..","--","-.",
	"---",".--.","--.-",".-.","...","-",
	"..-","...-",".--","-..-","-.--","--.."
};


char isMorseCode(string s){
	int i;
	char res;
	for (i = A; i <= Z; i++){
		if (morseCode[i - 'A'] == s){
			res = (char)i;
			break;
		}
	}
	if (s == "..--") res = '_';
	else if (s == "---.") res = '.';
	else if (s == ".-.-") res = ',';
	else if (s == "----") res = '?';
	return res;
}


char* isString(int c){
	switch (c){
		case underscore:
			return "..--";
		case period:
			return "---.";
		case comma:
			return ".-.-";
		case questionmark:
			return "----";
		default:
			return morseCode[c - 'A'];
	}
}


void solve(int t, string msg){
	printf("%d: ", t);
	int each_code[100];
	string s;
	string tmp="";
	int i, sz=msg.size();
	for (int i = 0; i < sz; i++){
		s = isString(msg[i]);
		each_code[i] = s.size();
		tmp += s;
	}
	for (i = sz - 1; i >= 0; i--){
		printf("%c", isMorseCode(tmp.substr(0, each_code[i])));
		tmp = tmp.substr(each_code[i]);
	}
	printf("n");
}


int main(){
	int T,tt=0;
	string s;
	scanf("%d", &T);
	while (T--){
		cin>>s;
		solve(++tt, s);
	}
    return 0;
}{% endhighlight %}
