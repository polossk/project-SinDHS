---
layout: post
title: "LightOJ 1128 最小公共祖先LCA离线算法 Greatest Parent"
date: 2013-10-04 20:29:43 +0800
categories: contest datastructure
tags: acmicpc lightoj lca
---
题目地址<a title="LightOJ 1128" href="http://lightoj.com/volume_showproblem.php?problem=1128" target="_blank">-></a>

题目很简单，就是求最近公共祖先的裸题，还是先介绍下的好。

最小公共祖先（LCA）：对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u、v的祖先且x的深度尽可能大。

另一种理解方式是把T理解为一个无向无环图，而LCA(T,u,v)即u到v的最短路上深度最小的点。

这里给出一个LCA的例子：

对于T=<V,E>：V={1,2,3,4,5}，E={(1,2),(1,3),(3,4),(3,5)}

则有：

LCA(T,5,2)=1

LCA(T,3,4)=3

LCA(T,4,5)=3

那么如何求解呢？下面介绍LCA离线算法 - Tarjan算法

LCA离线算法 - Tarjan算法

首先要了解这个算法的核心思想，那就是“空间换时间”。所应用到的搜索算法是深度优先遍历DFS，然后应用并查集来实现快速的查询访问。

对整个树进行深度优先遍历，并在遍历的过程中不断地把一些目前可能查询到的并且结果相同的节点用并查集合并。伪代码如下：

{% highlight delphi %}
LCA(u){
	Make-Set(u)
	ancestor[Find-Set(u)]=u
	对于u的每一个孩子v {
		LCA(v)
		Union(u)
		ancestor[Find-Set(u)]=u
	}
	checked[u]=true
	对于每个(u,v)属于P{
		if checked[v]=true
		then 回答u和v的最近公共祖先为 ancestor[Find-Set(v)]
	}
}{% endhighlight %}

Code Here

{% highlight cpp %}
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

const int Maxn=100010;

int stk[Maxn],size;
int v[Maxn],p[Maxn],ans[Maxn];

struct QUE{
	int val,pos;
}que;

vector<QUE> q[Maxn];//Query List
vector<int> vec[Maxn];

int bsearch(int val){
	int l=1,r=size;
	while (l<=r){
		int mid=(l+r)/2;
		if (v[stk[mid]]>=val)r=mid-1;
		else l=mid+1;
	}
	return stk[r+1];
}

int dfs(int r){
	int i;
	stk[++size]=r;
	for (i=0;i<q[r].size();i++){
		ans[q[r][i].pos]=bsearch(q[r][i].val);
	}
	for (i=0;i<vec[r].size();i++){
		dfs(vec[r][i]);
	}
	size--;
}

void solve(int tt){
    int n,m,i,tnode;
    printf("Case %d:n",tt);
    scanf(" %d %d",&n,&m);
    v[0]=1;
    for (i=0;i<n;i++){
        vec[i].clear();
        q[i].clear();
    }
    for (i=1;i<n;i++){
        scanf(" %d %d",&p[i],&v[i]);
        vec[p[i]].push_back(i);
    }
    for (i=0;i<m;i++){
        scanf(" %d %d",&tnode,&que.val);
        que.pos=i;
        q[tnode].push_back(que);
    }
    size=0;
    dfs(0);
    for (i=0;i<m;i++){
        printf("%dn",ans[i]);
    }
}

int main(){
	int T,tt=0;
	scanf(" %d",&T);
	while (T--){
		solve(++tt);
	}
	return 0;
}{% endhighlight %}
