---
layout: post
title:  "POJ 1808 Quadratic Residues 勒让德符号 平方剩余"
date:   2013-08-21 18:13:00 +0800
categories: contest math
tags: acmicpc poj numbertheory mod
---

题目地址[->](http://poj.org/problem?id=1808)

数论中的勒让德符号的一道裸题，直接用定义即可。

下面讲解勒让德符号。勒让德符号，或二次特征，是一个由阿德里安-马里•勒让德在1798年尝试证明二次互反律时引入的函数。这个符号是许多高次剩余符号的原型，a对p的勒让德符号，记做$$(\frac ap)$$或一般写成(a\|p)。

用处

那么他是用来干什么的呢？简单地说，是为了判断平方剩余方程是否有解时的一个参数。当然他还有很多用处，比如在素数判断和密码学中都是十分重要的一个参数。首先介绍欧拉判别条件：

定理1.1：d是模p的二次剩余的充要条件是：

$$d^{\frac{p-1}{2}} \equiv 1 \pmod p$$

d是模p的非二次剩余的充要条件是：

$$d^{\frac{p-1}{2}} \equiv -1 \pmod p$$

具体的证明过程请详见《初等数论（第三版）》5.2，现在不在过多陈述。

欧拉判别条件对一个较小的p值的判断十分简洁，但是如果p的值十分的庞大时，就会变得异常麻烦。因而便有了我们的勒让德符号。对规定如下：

$$(\frac ap) = \begin{cases}
1, & a \text{是模} p \text{的平方剩余} \\
-1, & a \text{是模} p \text{的平方非剩余} \\
0, & (p|a)
\end{cases}$$

因而，我们可以立即得出以下性质：

1.	$$(\frac{a}{p}) \equiv a^{\frac{p-1}{2}} \pmod p$$
2.	$$(\frac{a}{p})(\frac{b}{p})=(\frac{ab}{p})$$
3.	$$(\frac{a}{p})=(\frac{a+p}{p})$$
4.	$$(\frac{2}{p})=(-1)^{\frac{p^2-1}{8}}$$
5.	$$(\frac{-1}{p})=(-1)^{\frac{p-1}{2}}, (\frac{1}{p})=1$$
6.	$$(\frac{p}{q})=(-1)^{\frac{p-1}{2}\frac{q-1}{2}}(\frac{q}{p})$$

为了方便理解，给大家一个例子：

$$\begin{split}
(\frac{12345}{331}) &= (\frac{3}{331})(\frac{5}{331})(\frac{823}{331}) \\
 = (\frac{3}{331})(\frac{5}{331})(\frac{161}{331}) \\
&= (\frac{3}{331})(\frac{5}{331})(\frac{7}{331})(\frac{23}{331}) \\
&= (-1)(\frac{331}{3})(\frac{331}{5})(-1)(\frac{331}{7})(-1)(\frac{331}{23}) \\
&= (-1)(\frac{1}{3})(\frac{1}{5})(\frac{2}{7})(\frac{9}{23}) \\
 = (-1)(\frac{1}{3})(\frac{1}{5})(\frac{2}{7})(\frac{3}{23})^2 \\
&= (-1)(1)(1)(1)(1) \\
&= -1
\end{split}$$

# 编程实现

要考虑到乘法计算和乘方计算的精度问题，保险的话用乘法也用快速取模运算的乘法。在精度允许的条件下，直接用欧拉判别条件即可。
{% highlight cpp %}
/*
*函数名：Legendre
*作用：
*	给定d,p（n为奇质数），求(d|p)
*传入参数：
*	int64	d	参数d
*	int64	p	奇素数n
*辅助函数：
*	int64 q_mul_mod(int64 a,int64 b,int64 m)
*		快速乘函数，用于计算a*b mod m
*	int64 q_pow_mod(int64 a,int64 b,int64 m)
*		快速幂函数，用于计算a^b mod m
*传出数据：
*	(d|p)
*时间复杂度：
*	O(logp)
*注意事项：
*	本计算方法为暴力方法请注意精度和时间开销。
*/
int64 q_mul_mod(int64 a,int64 b,int64 m);
int64 q_pow_mod(int64 a,int64 b,int64 m);
int64 Legendre(int64 d,int64 p){
	d%=p;
	if(d==0) return 0;
	if (q_pow_mod(d,(p-1)/2,p)==1){
		return 1;
	}
	else return -1;
}
{% endhighlight %}

POJ1808的难点在于负数范围的处理。我们直接用性质2和性质5先将-1分离出来就行了。

# Code Here

{% highlight cpp %}
/****
	*@Polo-shen
	*
	*/
#include <iostream>
#include <string>
#include <cstring>
#include <cstdio>
#include <vector>

using namespace std;
typedef long long int64;

int64 q_mul_mod(int64 a,int64 b,int64 m);
int64 q_pow_mod(int64 a,int64 b,int64 m);
int64 Legendre(int64 d,int64 p){
	if (d>0){
		d%=p;
		if(d==0) return 0;
		if (q_pow_mod(d,(p-1)/2,p)==1){
			return 1;
		}
		else return -1;
	}
	else{
		int64 coef=((p-1)%4==0)?1:-1;
		d=-d;d%=p;
		if(d==0) return 0;
		if (q_pow_mod(d,(p-1)/2,p)==1){
			return coef;
		}
		else return -coef;
	}
}

int main(){
	int64 a,b,i=0,T;
	cin>>T;
	while (T--){
		cin>>a>>b;
		cout<<"Scenario #"<<++i<<":"<<endl;
		cout<<((Legendre(a,b)==-1)?-1:1)<<endl;
		cout<<endl;
	}
    return 0;
}

int64 q_mul_mod(int64 a,int64 b,int64 m){
	a%=m;
	b%=m;
	int64 t=0;
	while (b){
		if (b&1){
			t+=a;
			if (t>=m)t-=m;
		}
		a<<=1;
		if (a>=m)a-=m;
		b>>=1;
	}
	return t;
}

int64 q_pow_mod(int64 a,int64 b,int64 m){
	int64 ans=1;
	a%=m;
	while (b){
		if (b&1){
			ans=q_mul_mod(ans,a,m);
			b--;
		}
		b/=2;
		a=q_mul_mod(a,a,m);
	}
	return ans;
}
{% endhighlight %}