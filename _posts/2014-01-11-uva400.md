---
layout: post
title: "UVa 400 Unix Is 字符串整理与排版输出"
date: 2014-01-11 01:51:49 +0800
categories: contest serach
tags: acmicpc uva basicsearch
---
题目地址<a title="UVa 400" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=98&page=show_problem&problem=341" target="_blank">-></a>

题目的意思是对一个给定的字典先进行排序处理，之后再规范输出。

我的做法是，在输入字典的同时记录字典中单词的最大长度maxl。随后对字典进行一次快排（按字典序）。由于每一行的字母量一定（因为一个单词的最大长度不超过60，而且单词间要保留2个空格，所以每一行的最大字母量为62），所以用总数（62）除以每一块的长度（maxl + 2）得到一共需要的行数（c），再用r = (n - 1) / c + 1计算列数。最后输出时只需要特判该元素是否为这一行的最后一列即可。针对输出的单词，利用小技巧把输出“字符串 + 若干空格”封装成函数。时间复杂度是同样是O(nlogn).

具体的请看代码吧！

Code Here

{% highlight cpp %}
/****
	*@PoloShen
	*Title:UVaOJ 400
	*/
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <string>
#include <vector>
using namespace std;

vector<string> wl;

void Read(int num, int& maxl){
	string str; maxl = 0; wl.clear();
	while (num--){
		cin >> str;
		wl.push_back(str);
		int l = str.size();
		if (l > maxl) maxl = l;
	}
}

inline void strPrint(string s, int bufsize){
	int sz = s.size();
	int nspace = bufsize - sz;
	printf("%s", s.c_str());
	while (nspace--) printf(" ");
}

void Print(int n, int c, int r, int maxl){
	printf("------------------------------------------------------------n");
	for (int i = 0; i < r; ++i) {
		for (int j = 0; j < c; ++j) {
			int tmp = j * r + i;
			if (tmp >= n) continue;
			if (tmp >= ((int)((n-1)/r))*r)
				strPrint(wl[tmp], maxl);     // 如果为最后一列
			else
				strPrint(wl[tmp], maxl + 2);
		}
		printf("n");
	}
}

void solve(int n){
	int maxl = 0;
	Read(n, maxl);
	sort(wl.begin(),wl.end());
	int c = 0, r = 0;
	c = 62 / (maxl + 2);
	r = (n - 1) / c + 1;
	Print(n, c, r, maxl);
}

int main(){
	int n = 0;
	while (cin >> n) solve(n);
    return 0;
}{% endhighlight %}

 

