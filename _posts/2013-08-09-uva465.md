---
layout: post
title:  "UVa 465 Overflow 浮点数的优势"
date:   2013-08-09 21:38:00 +0800
categories: contest math
tags: acmicpc uva highprecision
---
算法很有启发性，值得一赞！原博文地址：

<http://blog.csdn.net/zcube/article/details/8458888>

这道题体现了浮点数的优势。即使用64位整数（注意long long要I64d输出），溢出也会变成负数，判断起来比较困难。如果用double类型，即使字符串位数超过百位，同样用sscanf()函数进行处理，却不会变成负数。原因是浮点数可以用指数表示。例如，double的正值取值范围为 4.94065645841246544E-324 到 1.79769313486231570E+308。意思是可以将上300位字符串形式转换成双精度浮点数，最多会丢失精度而已。知道这个性质后，用双精度浮点数来解决这道题就异常简单了。

{% highlight cpp %}
#include <stdio.h>
const int MINT = 0x7fffffff;
int main() {
    char str1[1000], str2[1000], ch;
    while (scanf("%s %c %s", str1, &ch, str2) != EOF) {
        printf("%s %c %sn", str1, ch, str2);
        double a, b;
        sscanf(str1, "%lf", &a);
        sscanf(str2, "%lf", &b);
        if (a > MINT)
            printf("first number too bign");
        if (b > MINT)
            printf("second number too bign");
        if ('+'==ch && a+b>MINT)
            printf("result too bign");
        if ('*'==ch && a*b>MINT)
            printf("result too bign");
    }
    return 0;
}
{% endhighlight %}
之前，我用long long长整型处理，纵然各种处理依然会wrong。最后受<http://blog.sina.com.cn/s/blog_8ee62ecb0100wpjm.html>这篇博文启发。感谢原作者简洁优美的代码