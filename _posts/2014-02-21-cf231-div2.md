---
layout: post
title: "[比赛记录] Codeforces Round #231 (Div. 2)"
date: 2014-02-21 02:11:30 +0800
categories: solution contest
tags: codeforces
---
# A. Counting Sticks

题目意思是讲一堆砖，就是竖线丨，你理解成火柴也可以，不影响。好的回归逗比题解，哦不逗比解题，哦不，逗比，逗比的我的题解。简单的暴力试探就行。

结果他妹的WA了

他妹的！

原因在于，处理前处理后，A，B，C都要大于1。。。

哦呵呵呵，妥了。

代码写的不够漂亮，不要在意。
{% highlight cpp %}
/****
    *@PoloShen
    *Title:A
    */
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
using namespace std;

#include <vector>
#include <list>
#include <stack>
#include <deque>
#include <queue>

inline void print(int n){ while (n--) printf("|"); }

string s;
int a[3];
void solve(){
    memset(a, 0, sizeof(a));
    int j = 0;
    int sz = s.size();
    for (int i = 0; i < sz; i++){
        if (s[i] == '|') a[j]++;
        else j++;
    }
    //for (int i = 0; i < 3; i++){
    //    printf("%c = %d, ", 'A'+i, a[i]);
    //}
    //printf("n");
    if ( (a[0]) + (a[1]) == (a[2]) ){
        print(a[0]);
        printf("+");
        print(a[1]);
        printf("=");
        print(a[2]);
        printf("n");
        return;
    }
    else if ( (a[0] + 1) + (a[1] - 1) == (a[2]) && a[1] >= 2){
        print(a[0] + 1);
        printf("+");
        print(a[1] - 1);
        printf("=");
        print(a[2]);
        printf("n");
        return;
    }
    else if ( (a[0] + 1) + (a[1]) == (a[2] - 1) && a[2] >= 2){
        print(a[0] + 1);
        printf("+");
        print(a[1]);
        printf("=");
        print(a[2] - 1);
        printf("n");
        return;
    }
    else if ( (a[0] - 1) + (a[1] + 1) == (a[2]) && a[0] >= 2){
        print(a[0] - 1);
        printf("+");
        print(a[1] + 1);
        printf("=");
        print(a[2]);
        printf("n");
        return;
    }
    else if ( (a[0] - 1) + (a[1]) == (a[2] + 1) && a[0] >= 2){
        print(a[0] - 1);
        printf("+");
        print(a[1]);
        printf("=");
        print(a[2] + 1);
        printf("n");
        return;
    }
    else if ( (a[0]) + (a[1] + 1) == (a[2] - 1) && a[2] >= 2){
        print(a[0]);
        printf("+");
        print(a[1] + 1);
        printf("=");
        print(a[2] - 1);
        printf("n");
        return;
    }
    else if ( (a[0]) + (a[1] - 1) == (a[2] + 1) && a[1] >= 2){
        print(a[0]);
        printf("+");
        print(a[1] - 1);
        printf("=");
        print(a[2] + 1);
        printf("n");
        return;
    }
    else printf("Impossiblen");
}

int main(){
    while (getline(cin, s)) solve();
    return 0;
}
{% endhighlight %}

# B. Very Beautiful Number
首先，什么是漂亮数呢？就是一个p位整数A，A乘x结果B，A和B所用的数码都是一样的，就说这个玩意是漂亮数。<br />
首先为大家普及一个知识：对一个素数p，1/p这个分数的循环节至多有p-1位。<br />
——你他妹的说这个有啥用？<br />
这道题我想的是从x到9开始枚举

如果你有大数的模板，或者JAVA，直接这么写就行了，但是苦逼的C/C++强烈建议各大OJ支持使用Boost库！好吧，过度意淫伤身。。。

{% highlight cpp %}
/****
    *@PoloShen
    *Title:B
    */
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
const int MAXN = 1000005;
int s[MAXN],t[MAXN];

void solve(int p, int x){
    for (int i = x; i <= 9; i++){
        memset(s, 0, sizeof(s));
        memset(t, 0, sizeof(t));
        s[1] = i;
        for (int j = 1; j <= p; j++){
            t[j]     += s[j] * x;
            t[j + 1] += t[j] / 10;
            t[j]     %= 10;
            s[j + 1]  = t[j];
        }
        if (t[p+1] == 0 && s[p] != 0 && t[p] == i){
            for (int i = p; i > 0; i--) printf("%d",s[i]);
            printf("n");
            return;
        }
    }
    printf("Impossiblen");
    return;
}

int main(){
    int p,x;
    scanf("%d%d", &p, &x);
    solve(p, x);
}
{% endhighlight %}

# C. Dominoes

先放11，再放10和01。<br />
贪心搞起。

{% highlight cpp %}
/****
    *@neko01
    *Title:C
    */
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;

int a[1050][1050];
char s[5];
int main()
{
    int n,m;
    scanf("%d%d", &n, &m);
    int b = 0, c = 0, d = 0, e = 0;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            scanf("%s", s);
            if (s[0] == '0' && s[1] == '0') a[i][j] = 0, b++;
            if (s[0] == '0' && s[1] == '1') a[i][j] = 1, c++;
            if (s[0] == '1' && s[1] == '0') a[i][j] = 2, c++;
            if (s[0] == '1' && s[1] == '1') a[i][j] = 3, e++;
        }
    }
    int cc = c / 2;
    c -= cc;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (e)      { a[i][j]=3; e--; }
            else if (c) { a[i][j]=1; c--; }
            else if (cc && a[i-1][j] == 1) { a[i][j]=2; cc--; }
            else if (b) { a[i][j] = 0; b--; }
            else if (cc){ a[i][j] = 2; d--; }
            if (a[i][j] == 0)  printf("00 ");
            else if (a[i][j] == 1) printf("01 ");
            else if (a[i][j] == 2) printf("10 ");
            else printf("11 ");
        }
        printf("n");
    }
    return 0;
}
{% endhighlight %}

# D. Physical Education and Buns

题目意思是说，给一个序列，对序列里的数据有三种操作，增加，减少，或者不变。其中，经过处理之后要求整个序列可以排列成一个递增的等差数列。求一个数ans，使得每个数据的改变量不超过ans。

枚举公差，二分ans就可以了。

{% highlight cpp %}
/****
	*@PoloShen
	*Title:D
	*/
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
using namespace std;

int arr[1005];
int n;

void solve(){
    for (int i = 0; i < n; i++){ scanf("%d", &arr[i]); }
    sort(arr, arr + n);
    int l = 0, r = 0, ans = 2000000000;
    int ar0 = 0, det = 0;
    for (int d = 0; d < 20001; d++){
        l = r = 0;
        for (int i = 1; i < n; i++){
            l = min(l, arr[0] + i * d - arr[i]);
            r = max(r, arr[0] + i * d - arr[i]);
        }
        int pos = arr[0];
        l = -l;
        if (l < r){
            int mid = (l + r) / 2 - l;
            l += mid; r -= mid; pos -= mid;
        }
        if (r < l){
            int mid = (l + r) / 2 - r;
            l -= mid; r += mid; pos += mid;
        }
        l = -l;
        while (-l < r){ l--; r--; pos--; }
        while (-l > r){ l++; r++; pos++; }
        if (ans > r){ ans = r; ar0 = pos; det = d; }
    }
    printf("%dn", ans);
    printf("%d %dn", ar0, det);
}

int main(){
    scanf("%d", &n); solve();
    return 0;
}{% endhighlight %}
