---
layout: post
title: "NPOJ(BETA) 1022 纪念远去的DOTA——DOTA大联欢(NWPU SRM of 2013.Dec E) 二分查找"
date: 2013-12-09 23:29:20 +0800
categories: contest algorithm
tags: acmicpc nwpuacm bsearch
---
# 纪念远去的DOTA ———— DOTA大联欢

时间限制: 1000 ms 内存限制: 65535 kB

## 题目描述

有一天你在西工大举办了一场DOTA大联欢活动，有N个擅长打DOTA的同学来参加，为了让比赛更加精彩，每轮比赛都要从N个同学中选一个同学来当解说，对赛况进行直播。但是做为DOTA爱好者以及想和其他同学切磋DOTA技艺，参加的N个同学都不是很想当解说。做为举办者，经过调查你知道了每个同学他想作为打比赛者的最少的轮数。第i个学生想打的轮数为ai。作为活动的举办者，你当然想满足每个参加活动同学的打比赛的最小轮数，但是为了控制成本，你想让比赛的轮数尽可能少。现在你的目标就是求出这个最小的轮数，使得活动结束后，每个参加活动的同学想打的比赛都可以在这个轮数内实现。

## 输入

有多个测试数据，测试数据不大于50，每个测试数据都由两行组成，第一行为N，表示有N个参加活动的同学（2<n<10^5）,第二行包含N个被空格隔开的整数a1,a2,….,an(1≤ai≤10^9),每个ai代表第i个同学想作为打比赛者的最少的轮数。

## 输出

对于每个测试数据，输出一个整数，表示你应该举办比赛的最少轮数以满足每个参加活动同学打比赛的最小轮数。每个测试数据的输出占一行。

## 示例输入

3

1 1 1

4

2 3 4

1

## 示例输出

2

4

## 提示

例如第一个样例，第一轮由第一个人当解说，另外第二第三人作为打比赛者，第二轮由第二个人当解说，第一第三个人作为打比赛者，这样第一个人打了1场，第二个人打了1场，第三个人打了2场，都满足。

# 题解

首先声明下，这份题解是昌昌写的。我是搬运工=。=

对于每个二分枚举的X,每个人当解说的次数肯定要小于和等于x-ai，然后每个ai都是固定的，然后每个人当解说的场数和sigma(x-ai)肯定大于等于X,而且又由于sigma(x-ai)随着x的增加成单调递增。所以就可以用二分来找到临界点。

要学会分析数据的特点关系，这个对解决题目的帮助特别大。

上界是MAX(ai),下界是INF

当然，如果想暴力，恭喜你，5M的输入数据不是白瞎的，祖传大数据，专治纯暴力！

# Code Here

{% highlight cpp %}
#include <iostream>
#include <cstdio>
#include <cmath>
#include <string>
#include <cstring>
using namespace std;

#define M 100050
#define INF (((long long)1<<62)-1)

long long pri[M];
int n;

/*
对于每个二分枚举的X,每个人当解说的次数肯定要小于和等于x-ai，
然后每个ai都是固定的，
然后每个人当解说的场数和sigma(x-ai)肯定大于等于X,而且又由于sigma(x-ai)随着x的增加成单调递增
所以就可以用二分来找到临界点。
要学会分析数据的特点关系，这个对解决题目的帮助特别大
上界是MAX(ai),下界是INF
*/
bool solve(long long x){
    int i;
    long long sum=0;
    for(i=0;i<n;i++){
        long long temp=x-pri[i];
        if(temp<0)return false;
        sum+=temp;
        if(sum>INF)return true;//预防溢出
    }
    if(sum>=x)return true;
    return false;
}
long long binary(long long l,long long r){
    long long mid;
    while(l<=r){
        mid=(l+r)>>1;
        if(solve(mid))r=mid-1;
        else l=mid+1;
    }
    return l;
}
int main()
{
    int i;
    long long MAX;
    while(scanf("%d",&n)!=EOF){
        MAX=-INF;
        for( i=0;i<n;i++){
             scanf("%I64d",&pri[i]);
             MAX=max(pri[i],MAX);
        }
        long long ans=binary(MAX,INF);
        printf("%I64dn",ans);
    }
    return 0;
}{% endhighlight %}
