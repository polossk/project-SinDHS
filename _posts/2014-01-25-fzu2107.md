---
layout: post
title: "FZU 2107 Hua Rong Dao 回溯搜索"
date: 2014-01-25 20:34:44 +0800
categories: contest dp serach
tags: acmicpc fzu szipdp dfs
---
题目地址<a title="FZU 2104" href="http://acm.fzu.edu.cn/problem.php?pid=2107" target="_blank">-></a>

当时我没怎么多想，感觉上应该答案直接暴力搜素的话可能会超时，然后就注意了下N的范围，N最大不超过4，那么其实这个问题是可以暴力搜索出结果的。但是为了保险，我还是现在本地运行得到结果后提交了答案打表的代码。

其实说实在话搜索的编码难度并不大，而且以前做数模的时候遇到过这种类似的问题，所以直接就用回溯写了。为了方便计数，放置顺序我设定成了2x2、2x1、1x2、1x1，这样感觉上是剪枝了，否则搜索空间太大有可能爆栈。

其实还有一种状态压缩DP的解法，我就直接把那种解法的代码贴上去了。

Code Here

搜索dfs

{% highlight cpp %}
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=(1<<4);
int f[6][N][2]={0};//f[i][j][k]//放完第i-1行第i行的状态j，k=1放曹操
void dfs(int row,int col,int pre,int now,int cao,int k){
    if(col>=4){//放完4列,pre={1111}
        f[row][now][cao]+=k;//放完pre得到f[now]+=f[pre]
        //cout<<row<<" "<<now<<" "<<cao<<endl;
        return;
    }
    if(pre&(1<<col)){//第col已经放过
        dfs(row,col+1,pre,now,cao,k);
        return;
    }
    //a grid
    dfs(row,col+1,pre|(1<<col),now,cao,k);
    //a 1*2
    dfs(row,col+1,pre|(1<<col),now|(1<<col),cao,k);//放一竖，多出一块
    int t=(1<<col)|(1<<(col+1));
    if(col<3&&(pre&(1<<(col+1)))==0){
        //a 2*1
        dfs(row,col+1,pre|t,now,cao,k);
        //put caocao
        if(cao==0)dfs(row,col+1,pre|t,now|t,1,k);
    }
}
int main(){
    int i,j,k;
    f[0][N-1][0]=1;
    for(i=1;i<=5;i++)
        for(j=0;j<N;j++){
            if(f[i-1][j][0])dfs(i,0,j,0,0,f[i-1][j][0]);
            if(f[i-1][j][1])dfs(i,0,j,0,1,f[i-1][j][1]);
        }
    scanf("%d",&k);
    while(k--){
        scanf("%d",&i);
        printf("%dn",f[i+1][0][1]);
    }
    return 0;
}{% endhighlight %}

打表
{% highlight cpp %}
/****
    *@PoloShen
    *Title:F
    */
#include <cstdio>
using namespace std;
short ans[5] = {0, 0, 18, 284, 4862};
short t, n;
int main(){
    scanf("%d", &t);
    while (t--){
        scanf("%d", &n);
        printf("%dn", ans[n]);
    }
    return 0;
}
{% endhighlight %}

状压DP

{% highlight cpp %}
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=(1<<4);
int f[6][N][2]={0};//f[i][j][k]//放完第i-1行第i行的状态j，k=1放曹操
void dfs(int row,int col,int pre,int now,int cao,int k){
    if(col>=4){//放完4列,pre={1111}
        f[row][now][cao]+=k;//放完pre得到f[now]+=f[pre]
        //cout<<row<<" "<<now<<" "<<cao<<endl;
        return;
    }
    if(pre&(1<<col)){//第col已经放过
        dfs(row,col+1,pre,now,cao,k);
        return;
    }
    //a grid
    dfs(row,col+1,pre|(1<<col),now,cao,k);
    //a 1*2
    dfs(row,col+1,pre|(1<<col),now|(1<<col),cao,k);//放一竖，多出一块
    int t=(1<<col)|(1<<(col+1));
    if(col<3&&(pre&(1<<(col+1)))==0){
        //a 2*1
        dfs(row,col+1,pre|t,now,cao,k);
        //put caocao
        if(cao==0)dfs(row,col+1,pre|t,now|t,1,k);
    }
}
int main(){
    int i,j,k;
    f[0][N-1][0]=1;
    for(i=1;i<=5;i++)
        for(j=0;j<N;j++){
            if(f[i-1][j][0])dfs(i,0,j,0,0,f[i-1][j][0]);
            if(f[i-1][j][1])dfs(i,0,j,0,1,f[i-1][j][1]);
        }
    scanf("%d",&k);
    while(k--){
        scanf("%d",&i);
        printf("%dn",f[i+1][0][1]);
    }
    return 0;
}{% endhighlight %}