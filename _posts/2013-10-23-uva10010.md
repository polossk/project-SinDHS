---
layout: post
title: "Uva 10010 Where's Waldorf? 基础的字符串处理"
date: 2013-10-23 13:51:03 +0800
categories: contest string
tags: acmicpc uva basicstring
---
题目地址<a title="UVa 10010" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=96&page=show_problem&problem=951" target="_blank">-></a>

其实真正在成都打铁的原因就是基础知识不牢固，比如说这道简单的字符串入门题目我WA了4次=。=

先翻译一下，题目会给你一个n * m的一个字符表，不考虑字母的大小写。随后给你一个容量为index的单词本，让你在字符表中查找单词，并且输出第一个字母所在位置。保证每一个单词都能找到。查找方式为：

<blockquote>
<ol>
<li>从上到下，从左往右。</li>
<li>如果字符表中的字母与单词的首字母匹配成功，则开始从左上、左下、右上、右下、正上、正下、正左、正右共8个方向进行匹配，如果匹配成功，输出首字母的所在坐标，匹配失败则接着查找首字母。</li>
</ol>
</blockquote>


同时请注意，每两组数据之间输出后加空行（WA一次）。

为了懒省事，我用了标准库中的<cctype>的toupper()函数把所有的字母直接转化成大写，同时借用了transform()函数。

具体应用如下。

string str;

transform(str.begin(),str.end(), str.begin(), ::toupper);// 把 str 里的字符都转成大写。

请大家注意！之所以写 ::toupper，因为这个toupper不是std命名空间的，必须加上全局空间标识符。

随后就是繁琐的细节问题了，主要是字符串问题的通病，麻烦和细节，唉=。=

Code Here

{% highlight cpp %}
/****
	*@PoloShen
	*Title:UVaOJ 10010 Where's Waldorf?
	*/
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
using namespace std;
#define LOCAL 0
#include <vector>
//#include <list>
//#include <stack>
//#include <deque>
//#include <queue>

#include <cctype>

#define DBG 0
#define ALG 1
#define USING_STL_STRING	1
#define USING_STL_VECTOR	1
#define USING_STL_LIST		0
#define USING_STL_STACK		0
#define USING_STL_DEQUE		0
#define USING_STL_QUEUE		0

#if DBG
	#include "F:\My Source Code\debug.h"
#else
	#define __DBG 0 &&
#endif // DBG

#if ALG
	#include <algorithm>
#else
	#ifndef min
		#define min(x,y) ((x) < (y) ? (x) : (y))
	#endif
	#ifndef max
		#define max(x,y) ((x) > (y) ? (x) : (y))
	#endif
#endif // ALG
namespace UVaOJ10010{
	const int Direction_cases = 8;
	int Direction[Direction_cases][2]{
		{-1, +1}, {0, +1}, {+1, +1},
		{-1,  0},		   {+1, 0 },
		{-1, -1}, {0, -1}, {+1, -1}
	};
	int N, M;
	int index;
	vector<string> dict;
	vector<string> words;
	void Read(){
		cin >> N >> M;
		for(int i = 0; i < N; i++){
			string line;
			cin >> line;
			transform(line.begin(), line.end(), line.begin(), ::toupper);
			dict.push_back(line);
		}
		cin >> index;
		for (int i = 0; i < index; i++){
			string word;
			cin >> word;
			transform(word.begin(), word.end(), word.begin(), ::toupper);
			words.push_back(word);
		}
	}

	bool inbound(int x, int L, int R){
		return (x <= R) && (x >= L);
	}

	void SearchWord(string word){
		int sz = word.size();
		bool flag = 0;
		for (int i = 0; i < N; i++){
			for (int j = 0; j < M; j++){
				if (dict[i][j] == word[0]){
					for (int d = 0;d < Direction_cases; d++){
						int searched = 1;
						for (int k = 1; k < sz; k++){
							int row = i + Direction[d][0] * k;
							int col = j + Direction[d][1] * k;
							if (inbound(row, 0, N - 1) && inbound(col, 0, M - 1)){
								;
							}
							else break;
							if (dict[row][col] == word[k]){
								searched++;
							}
							else break;
						}
						if(searched == sz){
							printf("%d %dn", i+1, j+1);
							flag = 1;
							return;
						}
						else{
							continue;
						}
					}
				}
				else continue;
			}
		}
		return;
	}

	void Clear(){
		dict.clear();
		words.clear();
	}

	void Solve(){
		Clear();
		Read();
		for (int i = 0; i < index; i++){
			SearchWord(words[i]);
		}
	}
};
using namespace UVaOJ10010;


int main(){
	int T;
	scanf("%d",&T);
	#if LOCAL
		freopen("a.in", "r", stdin);
		freopen("a.out", "w", stdout);
	#endif // LOCAL
	while (T--){
		UVaOJ10010::Solve();
		if (T > 0){
			printf("n");
		}
	}
    return 0;
}{% endhighlight %}
