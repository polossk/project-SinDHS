---
layout: post
title: "[比赛记录] Codeforces Round #239 (Div. 2)"
date: 2014-04-01 12:47:07 +0800
categories: contest solution
tags: codeforces
---
# A. Line to Cashier

题目意思就是收银台前排队，每个人需要 5 * x + 15秒完成结账，x是那个人买的东西，直接模拟求最小值即可。

像我这种弱渣上来因为最小值定义成100华丽丽的Wa一发。当时以为要输出第几个柜台。

{% highlight cpp %}
/****
    *@author    Shen
    *@title     a
    */

#include <iostream>
using namespace std;

typedef long long int64;

inline int calc(int t)
{
    return 15 + 5 * t;
}

int n;
int64 casher[105];
int number[105];

void solve(){
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> number[i];
    for (int i = 0; i < n; i++)
    {
        casher[i] = 0;
        for (int j = 0; j < number[i]; j++)
        {
            int k; cin >> k;
            casher[i] += calc(k);
        }
    }
    int ans = casher[0];
    for (int i = 0; i < n; i++)
    {
        if (casher[i] < ans) ans = casher[i];
    }
    cout << ans << endl;
}

int main(){
    solve();
    return 0;
}
{% endhighlight %}

# B. Garland

感觉这道题的难点在于读题不在于编码。题目的意思是，一个倒霉孩子有一大摞卡片，上面有颜色的标记，也就是输入数据的第一行aaabbac之类的，一个字母代表一种颜色。完事这个倒霉孩子想把这摞卡片整成一个颜色排列形式，也就是输入数据的第二行aabbccac之类的，一个字母表示一种颜色。询问能不能搞出来，和搞出来的卡片序列的最大长度单位是多少（原题中是面积，其实无关紧要，长度更方便理解而已）。

怎么去解决的？题目中有一个剪卡片操作，就是说，只要有一种颜色的卡片(比如说a)不够用了，我就可以把这个卡片剪开，这样就能当两个卡片用，而且保持面积不变。当然，我也可以丧心病狂的剪成一个又一个的细条用来充数，而且总面积不变。

所以我们只需要对每个颜色进行判断就行了。首先判断能不能成功：就是手上的颜色和目标颜色是否匹配。接着我们依次去比较相同颜色的手上的与目标的数量的大小关系。手上的多，那么一定就能搞出来，所以答案累加上目标颜色的数量；反之，我们照样能够通过剪纸的方法搞出来，只不过面积是手上的卡片的总数罢了。这样我们遍历一遍之后就能把答案搞出来。

{% highlight cpp %}
/****
    *@author    Shen
    *@title     b
    */

#include <iostream>
#include <cstdio>
using namespace std;

int ori[26], tar[26];

void Update(int buf[])
{
    char ch = 0;
    while (1)
    {
        scanf("%c", &ch);
        if (ch != 'n') buf[ch - 'a']++;
        else return;
    }
}

void solve(){
    Update(ori);
    Update(tar);
    int ans = 0;
    for (int i = 0; i < 26; i++)
    {
        if (tar[i] == 0) continue;
        else if (ori[i] == 0) { ans = -1; break; }
        else if (ori[i] >= tar[i]) ans += tar[i];
        else if (ori[i] < tar[i]) ans += ori[i];
    }
    cout << ans << endl;
}

int main(){
    solve();
    return 0;
}
{% endhighlight %}

# C. Triangle

这道题的意思是让你找一个直角三角形，满足其三条边都不与坐标轴平行。

首先我们固定一个点(0, 0)，因为三个点是任意的，我把直角所在的点固定更方便判断和找规律。

其次，考虑任意一条边。因为这条边不与坐标轴平行，而且这条边的起点与终点必定是一个整点，所以这个边一定与两个平行于坐标轴的线段构成直角三角形且满足勾股定律。那么另一条边也满足这个规律，所谓我们的核心问题就是判断这些可能的两条线段的终点能不能连出一个直角三角形的第三条边。当然，这个问题暴力就可以解决了，因为终点的个数很少，直接暴力搜索没有问题。

最后判断一下有没有平行于坐标轴即可。

{% highlight cpp %}
/****
    *@author    Shen
    *@title     c
    */

#include <set>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 4005;
int n, m;

struct Edge{
    int pos, val;
    bool operator<(const Edge& a)const{
        return a.val < val;
    }
}D;

set<Edge> myset;
set<Edge>::iterator p;

struct node{
    int x, y;
    node(int a = 0,int b = 0): x(a), y(b){}
}a[N],b[N];

int dis(node a, node b){
    int dx = a.x - b.x;
    int dy = a.y - b.y;
    return dx * dx + dy * dy;
}

int St[1001];

void solve(){
    int t = n * n + m * m;
    int t1 = 0, t2 = 0;
    n = n * n; m = m * m;
    for (int i = 1; i * i < n; i++)
    {
        D.val = n - i * i;
        p = myset.find(D); if (p==myset.end()) continue;
        D = *p;
        a[t1++] = node(i, D.pos);
        a[t1++] = node(i, -D.pos);
        a[t1++] = node(-i, D.pos);
        a[t1++] = node(-i, -D.pos);
    }
    for (int i = 1; i * i < m; i++)
    {
        D.val = m - i * i;
        p = myset.find(D); if (p==myset.end()) continue;
        D = *p;
        b[t2++] = node(i, D.pos);
        b[t2++] = node(i, -D.pos);
        b[t2++] = node(-i, D.pos);
        b[t2++] = node(-i, -D.pos);
    }
    if (t1 == 0 || t2 == 0){ puts("NO"); return; }
    bool ok = false;

    int i = 0, j = 0;

    for (i = 0; i < t1; i++)
    {
        for (j = 0; j < t2; j++)
            if (dis(a[i], b[j]) == t)
            {
                if (a[i].x == b[j].x || a[i].y == b[j].y) continue;
                if (a[i].x == 0 || a[i].y == 0 || b[j].x == 0 || b[j].y == 0) continue;
                ok = true; break;
            }
        if (ok) break;
    }
    if (ok == false) { puts("NO"); return; }
    puts("YES");
    puts("0 0");
    printf("%d %dn%d %dn", a[i].x, a[i].y, b[j].x, b[j].y);
}

int main(){
    myset.clear();
    for (int i = 0; i <= 1000; i++){
        Edge E={i, i * i};
        myset.insert(E);
    }
    while(~scanf("%d %d", &n, &m)) solve();
    return 0;
}
{% endhighlight %}

# D. Long Path

首先题目意思是说每一个房间有两个传送门（这样方便理解）。在i号房间中，第一个传送门指向下一个房间i+1，第二个房间指向p[i]号房间，且1 ≤ p[i] ≤ i。每一次主人公走进一个房间，他会先在房间内添上一个×。之后他会数房间现在（画完×之后）有多少个×。当房间有偶数个的时候，他会走第一个传送门，反之走第二个。

当去第一个传送门的时候，必然他已经来过一次这个房间了。所以如果他想去某一个房间，至少要去两次该房间的前一个房间。所以这就是一个动态规划问题了。

用dp[i]表示到从当前房间i-1走到下一房间i的花费。

状态转移方程dp[i + 1] = 2dp[i] + 2 - dp[pi]。

答案是∑dp[n + 1]。

{% highlight cpp %}
/****
	*@author    Shen
	*@title     d
	*/

#include <iostream>
#include <cstdio>
using namespace std;

const int Mod = 1000000007;
int p[1005], dp[1005];
int n;

void solve(){
    int r = 0;
    for (int i = 1; i <= n; i++) scanf("%d", &p[i]);
    for (int i = 1; i <= n; i++)
    {
        dp[i] = 2;
        for(int j = p[i]; j < i; j++) dp[i] += dp[j], dp[i] %= Mod;
        r += dp[i], r %= Mod;
    }
    printf("%dn", r);
}

int main(){
    while (cin >> n) solve();
    return 0;
}{% endhighlight %}
