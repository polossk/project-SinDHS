---
layout: post
title: "UVa 644 Immediate Decodability 字符串比较"
date: 2013-11-13 16:16:16 +0800
categories: contest string
tags: acmicpc uva basicstring
---
题目地址<a title="UVa 644" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=96&page=show_problem&problem=585" target="_blank">-></a>

不知道是题目太简单了还是什么，加了那么长的模板的代码竟然只有100行=。=诧异中。。。

题目的意思还是有些难懂，主要是给你一种编码方式，类似于摩尔斯电码的01编码，然后判断这个编码方式是不是完备的一个系统。那什么是完备系统呢？就是不会有歧义的编码就是一个完备的系统。比如说样例中所给的第一个编码方式：

<blockquote>A - 01

B - 10

C - 0010

D - 0000
</blockquote>

翻译0000 01 10 0000 01 0010 10 01 0000这个串时，只会有一种结果：D A B D A C B A D

同样的如果用第二种编码方式，表示同样的信息0000 01 10 0000 01 0010 10 01 0000时，会有不同的“断句”方式，从而导致歧义：

<blockquote>0000 01 10 0000 010 010 10 01 0000

D A B D C C B A D

0000 01 10 0000 010 01 010 01 0000

D A B D C A C A D
</blockquote>

那么如何判断完备系统呢？我们注意到在样例的第二组数据，只有A、C之间会发生歧义，因为，C：010是以A：01为前缀的新编码。所以我们猜测：

对于任意两组编码X，Y，只要XY不互为对方的前缀即可。

严格证明可以用反证法，不再赘述。剩下的就是编码了。

Code Here
{% highlight cpp %}
/****
	*@PoloShen
	*Title:
	*/
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
using namespace std;

#include <vector>
#include <list>
#include <stack>
#include <deque>
#include <queue>

vector<string> dict;
const string endflag = "9";
bool cmp(string str1, string str2){
	int len1 = str1.size();
	int len2 = str2.size();
	int len = (len1 > len2)? len2: len1;
	for (int i = 0; i < len; i++){
		if (str1[i] != str2[i])return 0;
		else continue;
	}
	return 1;
}

void Print(bool printflag, int casenum){
	if (!printflag){
		printf("Set %d is immediately decodablen", casenum);
	}
	else{
		printf("Set %d is not immediately decodablen",casenum);
	}
}

bool Judge(){
	int sz = dict.size();
	for (int i = 0; i < sz; i++){
		for (int j = i + 1; j < sz; j++){
			bool temp = cmp(dict[i], dict[j]);
			if (temp)return temp;
			else continue;
		}
	}
	return 0;
}

bool solve(int casenum){
	dict.clear();
	string str;
	bool termflag = 1;
	while (getline(cin, str)){
		if (str != endflag){
			dict.push_back(str);
		}
		else{
			bool flag = 1;
			flag = Judge();
			Print(flag, casenum);
			return 0;
		}
	}
	return termflag;
}

int main(){
//#define __LOCAL__
#ifdef __LOCAL__
	freopen("a.in", "r", stdin);
	freopen("a.out", "w", stdout);
#endif // __LOCAL__
	int casenum = 0;
	while (1){
		bool termflag = solve(++casenum);
		if (termflag)break;
	}
    return 0;
}{% endhighlight %}

 

