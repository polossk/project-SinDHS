---
layout: post
title: "LightOJ 1423 Olympic Swimming 散列表"
date: 2013-10-06 19:26:52 +0800
categories: contest datastructure
tags: acmicpc lightoj hash
---
题目地址<a title="LightOJ 1423" href="http://lightoj.com/volume_showproblem.php?problem=1423" target="_blank">-></a>

题目的意思是说，有k条长l的泳道，为了增加难度，会在每一条泳道上增加ni个障碍，障碍的坐标分别是p1,p2,...,pni。但是为了比赛的公平，必须保证每个运动员的泳道中障碍物的数量必须相同。同时为了照顾到资源的最大化利用，输出这个比赛场地可以让运动员公平竞赛的最大的泳道长度。算是一道比较简单的散列表的问题了，用STL来做，具体的请看代码吧，应该没什么大问题的。

Code Here
{% highlight cpp %}
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <map>

using namespace std;

typedef long long int64;
typedef unsigned long long Uint64;

const int MAXN=50050;
map<Uint64,int> g;
int ar[MAXN][30];
int cnt[30];
void solved(int tt) {
    int L,K,Q,p;
    scanf(" %d %d",&L,&K);
    g.clear();
    memset(ar,0,sizeof(ar));
    for (int i=0;i<K;++i) {
        scanf(" %d",&Q);
        while (Q--) {
            scanf(" %d",&p);
            ar[p][i]++;
        }
    }
    int ret=p=0;
    for (int i=0;i<L;++i) {
        int mi=L+1,ma=-1;
        for (int j=0;j<K;++j) {
            if (i) ar[i][j]+=ar[i-1][j];
            mi=min(mi,ar[i][j]);
            ma=max(ma,ar[i][j]);
        }
        if (mi == ma) ret=i+1;
        for (int j=0;j<K;++j) {
            cnt[j]=ar[i][j]-mi;
        }
        Uint64 tmp=0;
        for (int j=0;j<K;++j) {
            tmp *= 16777619;
            tmp ^= cnt[j];
        }
        int t=g[tmp];
        if (t) {
            ret=max(ret,i-t+1);
        }
        else {
            g[tmp]=i+1;
        }
    }
    printf("Case %d: %d meter(s)n",tt,ret);
}

int main (){
    int T;scanf(" %d",&T);
    int tt=0;
    while (T--){
        solved(++tt);
    }
    return 0;
}{% endhighlight %}
