---
layout: post
title: "UVa 409 Excuses, Excuses! 基础字符串查找处理题目"
date: 2013-11-11 20:39:34 +0800
categories: contest string
tags: acmicpc uva basicstring
---
题目地址<a title="UVa 409" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=96&page=show_problem&problem=350" target="_blank">-></a>

<blockquote>这道题目我WA了一个星期我会乱说？

先给大家解释下题目的意思。给你k个“理由”关键字，然后再来上l个“借口”。把包含最多关键字的“借口”输出。

我把可能WA的地方给大家说一下：

1、格式WA，就是说忘记了输出空行。

2、输出原句WA，就是说，输出的句子一定得是原来的句子，不能是你修改后的。

3、字母匹配问题，一定要用同一种表达方式来匹配，比如说我的代码里统一用的是大写，当然你也可以用小写，这个不是重点，重点在于统一。

4、句子中出现数字的问题。题目没有正面的说什么数字的处理问题。那我们就仔细的读题：

<blockquote>A keyword ``occurs" in an excuse if and only if it exists in the string in contiguous form and is delimited by the beginning or end of the line or any non-alphabetic character or a space.
</blockquote>

注意这句话，重点解释了对于关键字的出现和结束标志，请注意这个"non-alphabetic character or a space"，其实就是说，管他什么数字符号巴拉巴拉，全看成空格不会错。

5、重复关键字匹配问题。同样需要好好读题：

<blockquote>If a keyword occurs more than once in an excuse, each occurrance is considered a separate incidence.
</blockquote>

也就是说，会保证所给的关键字集合不会出现重复的，然后一旦出现重复的关键字，统一看做一个全新的关键字去处理。比如说如下情况：

<blockquote>Keywords:

home

Excuses:

home. my home.

home home home.
</blockquote>

第一个句子有两个关键字，总数为2；

第二个句子有三个关键字，总数为3；

如果正常运行，应当输出第二个句子。

6、人品问题。对，绝对是人品问题。如果脸太黑了，绝对会和我一样连续WA一个星期妥妥的！
</blockquote>

Code Here
{% highlight cpp %}
/****
	*@PoloShen
	*Title:
	*/
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

#include <vector>
#include <list>
#include <stack>
#include <deque>
#include <queue>

typedef string keyword;
typedef list<keyword> keywords;
keywords kws;
keywords query;

typedef string sentence;
typedef vector<sentence> sentences;
sentences origin;
//sentences fortest;

keywords Trans2Test(sentence ori){
	int sz = ori.size();
	int i = 0;
	sentence os = ori;
	keywords res;res.clear();
	keyword temp;temp.clear();
	for (; i < sz; i++){
		if (isalpha(os[i])){
			os[i]=toupper(os[i]);
		}
		else{
			os[i]=' ';
		}
	}
	os[sz]='';
	for (i = 0; i < sz; i++){
		if (os[i] == ' '){
			if (temp.empty()){
				continue;
			}
			else{
				res.push_back(temp);
				temp.clear();
			}
		}
		else{
			temp += os[i];
		}
	}
	if (!temp.empty()){
		res.push_back(temp);
		temp.clear();
	}
	return res;
}

void Read(int k, int l){
	getchar();
	kws.clear();
	origin.clear();
	for (int i = 0; i < k; i++){
		keyword temp;
		getline(cin, temp);
		transform(temp.begin(), temp.end(), temp.begin(), ::toupper);
		kws.push_back(temp);
	}
	kws.unique();kws.sort();
	for (int i = 0; i < l; i++){
		sentence temp;
		getline(cin, temp);
		origin.push_back(temp);
	}
}

void solve(int casenum, int k, int l){
	cout<<"Excuse Set #"<<casenum<<endl;
	Read(k, l);
	int cn[l];//cn means corresponding number
	int maxcn = -1;//means maxinum of corresponding number
	for (int i = 0; i < l; i++){
		query.clear();cn[i] = 0;
		query = Trans2Test(origin[i]);
		for (keywords::iterator it = query.begin(); it != query.end(); it++){
			for (keywords::iterator jt = kws.begin(); jt != kws.end(); jt++){
				if (*(it) == *(jt)){
					cn[i]++;break;
				}
			}
		}
		maxcn = (maxcn > cn[i])? maxcn: cn[i];
	}

	for (int i = 0; i < l; i++){
		if (cn[i] == maxcn){
			cout<<origin[i]<<endl;
		}
	}
	cout<<endl;
}

int main(){
#ifdef __LOCAL__
	freopen("a.in", "r", stdin);
	freopen("a.out", "w", stdout);
#endif // __LOCAL__
	int tt = 0;
	int k = 0, l = 0;
	while (scanf("%d %d", &k, &l)!=EOF){
		solve(++tt, k, l);
	}
    return 0;
}{% endhighlight %}
