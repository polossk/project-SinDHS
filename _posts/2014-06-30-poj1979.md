---
layout: post
title: "POJ 1979 Red and Black 深度优先搜索上手题"
date: 2014-06-30 01:28:31 +0800
categories: contest serach
tags: acmicpc poj dfs
---
题目地址<a title="POJ 1979" href="http://poj.org/problem?id=1979" target="_blank">-></a>

很简单的一道上手的深搜题目，题目意思很简单，就是不能走红色的砖。从起点开始深搜就行了。

Code Here
{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :POJ 1979
#       @file         :G:My Source Code¡¾ACM¡¿ÑµÁ·630 - ËÑË÷poj1979.cpp
#       @date         :2014/06/30 01:02
#       @algorithm    :DFS
******************************************************************************/

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long int64;
int w, h, cnt;
char gird[25][25];
//driection u,  d,  r,  l;
int dx[4] = { 0,  0,  1, -1};
int dy[4] = {-1,  1,  0,  0};

inline bool inbound(int l, int r, int x)
{
    return (x >= l && x < r);
}

inline bool check(int x, int y)
{
    return inbound(0, w, x) && inbound(0, h, y);
}

void dfs(int x, int y)
{
    if (!check(x, y)) return;
    else if (gird[x][y] == '@' || gird[x][y] == '.')
    {
        cnt++;
        gird[x][y] = '#';
        for (int i = 0; i < 4; i++)
            dfs(x + dx[i], y + dy[i]);
    }
}

void solve()
{
    memset(gird, 0, sizeof(gird));
    int sx = 0, sy = 0; cnt = 0;
    for (int i = 0; i < h; i++)
    for (int j = 0; j < w; j++)
    {
        scanf(" %c", &gird[j][i]);
        if (gird[j][i] == '@') sx = j, sy = i;
    }
    dfs(sx, sy);
    printf("%dn", cnt);
}

int main()
{
    while (scanf("%d%d", &w, &h))
    {
        if (w == 0 && h == 0) break;
        else solve();
    }
    return 0;
}{% endhighlight %}
