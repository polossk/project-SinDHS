---
layout: post
title: "HDU 4435 2012年天津现场赛 E charge-station 搜索题"
date: 2013-10-13 16:13:48 +0800
categories: contest serach
tags: acmicpc hdu bfs
---
题目地址<a title="HDU 4435" href="http://acm.hdu.edu.cn/showproblem.php?pid=4435" target="_blank">-></a>

一开始的确被繁琐的题目意思吓到了，大概是讲，有一些城市，还有一个开车的人，他的车最远一次加满油走D，为了走遍每一个城市，需要在其中的一些城市建立加油站。在第i个城市建立加油站的费用为2 ^ (i-1)，求最少的建立加油站的费用的方案。

一上来的确不好抉择，摸不清楚题目意思，只是知道求费用最小值的方案，然后还要十分麻烦的用二进制输出。但是这里有一个很明显的条件，那就是这个“在第i个城市建立加油站的费用为2 ^ (i-1)”，那么，对于第j个城市，如果在它之前的所有的城市都建立了加油站，所需费用依然会小于2 ^ (j-1)，等比数列求和很快就能发现这个隐藏条件。那么我觉得最好就是贪心求解了，先假设每个城市都是加油站，然后再从最后一个开始筛选。

然而，麻烦就麻烦在筛选这个步骤，怎么筛？纯暴力方法么？显然是不对的。

我的想法是首先假设城市i不再是加油站。那么我们接着建立一个visit数组，用于记录可以到达的城市，建立一个toStation数组，记录城市i最近的加油站的距离，如果自己是加油站那么就直接设置为0。最后开一个队列，用于记录广搜时当前状态所有经过的城市。通过一次广搜，把toStation数组建立好，然后就是对每一个城市i逐一分析：

<blockquote>如果自身是加油站(isStation[i] == 1)，但是根本没有访问到(visit[i] == 0)，那么这种安排方案失败。

如果自身不是加油站(isStation[i] == 0)，但是汽车无法在这个城市和加油站之间跑一个来回(2 * toStation[i] > d)，同样方案失败。

以上条件均满足，ok，方案成功。
</blockquote>

方案成功，就是说，如果城市i不再是加油站，我们题目中的主人公照样可以走遍所有的城市，那换句话说，这个城市就不是必须作为加油站的城市。在这道题目中，这句话的意思就是：城市i不是加油站。相反，方案失败，那就是说，这个城市必须作为加油站。

理清楚这些之后，输出-1的条件就很明显了，所有的城市都是加油站的条件下，方案失败了。注意，这里不要和刚才的那些东西混淆，这里讲的是输出-1的条件。

好了，具体的请结合代码研读吧！

Code Here

{% highlight cpp %}
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <queue>

using namespace std;

const int Maxn = 128;
const int Infi = 99999999;
int n, d;

typedef struct coordinate{
	double x, y;
}coor;

coor City[Maxn];
bool isStation[Maxn];
int path[Maxn][Maxn];

int dist(int i, int j){
	return ceil(
				sqrt(
					(City[i].x - City[j].x) * (City[i].x - City[j].x)
					+
					(City[i].y - City[j].y) * (City[i].y - City[j].y)
					)
				);
}

bool bfs(){
	bool visit[Maxn];
    int toStation[Maxn];
    memset(visit,0,sizeof(visit));
    for (int i = 0; i < n; i++){
		if (isStation[i])toStation[i] = 0;
		else toStation[i] = Infi;
    }
    visit[0] = 1;
    queue<int> citylist;
    citylist.push(0);
    while (!citylist.empty()){
        int u = citylist.front();
        citylist.pop();
        for (int i = 0; i < n; i++){
            if (!visit[i] && path[u][i] <= d){
                toStation[i] = min(toStation[i], toStation[u] + path[u][i]);
                if(isStation[i]){
                    citylist.push(i);
				visit[i] = 1;
                }
            }
        }
    }
    for(int i=0;i<n;i++){
        if(isStation[i] && !visit[i]) return 0;
        if(!isStation[i] && toStation[i] * 2>d) return 0;
    }
    return 1;
}

void read(int n){
	for (int i = 0; i < n; i++){
		scanf("%lf%lf", &City[i].x, &City[i].y);
	}
	return;
}

void setdis(int n){
	for (int i = 0; i < n; i++){
		for (int j = i; j < n; j++){
			path[i][j] = path[j][i] = dist(i, j);
		}
	}
	return;
}

void solve(int n, int d){
	for (int i = 0; i < n; i++) isStation[i]=1;
    if (!bfs()){
		printf("-1n");
		return;
	}
    for (int i = n - 1; i > 0; i--){
        isStation[i]=0;
        if(!bfs())isStation[i] = 1;
    }
    int j = n - 1;
    //直接用二进制输出了，去掉前面的零
    while (!isStation[j]) j--;
    for (int i = j; i >= 0; i--) printf("%d",isStation[i]);
    printf("n");
}

int main(){
	while (scanf("%d%d", &n, &d) != EOF){
		read(n);
		setdis(n);
		solve(n, d);
	}
	return 0;
}{% endhighlight %}
