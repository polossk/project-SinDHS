---
layout: post
title: "UVa 10815 Andy's First Dictionary 单词排序"
date: 2013-11-12 23:32:02 +0800
categories: contest string
tags: acmicpc uva basicstring
---
题目地址<a title="UVa 10815" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=96&page=show_problem&problem=1756" target="_blank">-></a>

题目的意思就是，把句子里的单词分离出来，整理排序。

所以说，上链表，一个句子一个句子分离单词，分离好了临时存一下，merge一个链表就合并了，sort一个就排好序了，unique就没有什么重复的了。

所以说，STL才是最好的模板。

具体看代码了

Code Here
{% highlight cpp %}
/****
	*@PoloShen
	*Title:
	*/
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

#include <vector>
#include <list>
#include <stack>
#include <deque>
#include <queue>

typedef string word;
typedef list<word> words;
typedef string sentence;
words result;
sentence origin;

words Trans2Test(sentence ori){
	int sz = ori.size();
	int i = 0;
	sentence os = ori;
	words res;res.clear();
	word temp;temp.clear();
	for (; i < sz; i++){
		if (isalpha(os[i])){
			os[i]=tolower(os[i]);
		}
		else{
			os[i]=' ';
		}
	}
	os[sz]='';
	for (i = 0; i < sz; i++){
		if (os[i] == ' '){
			if (temp.empty()){
				continue;
			}
			else{
				res.push_back(temp);
				temp.clear();
			}
		}
		else{
			temp += os[i];
		}
	}
	if (!temp.empty()){
		res.push_back(temp);
		temp.clear();
	}
	return res;
}
void solve(){
	while (getline(cin, origin)){
		words newwords = Trans2Test(origin);
		result.merge(newwords);
	}
	result.sort();
	result.unique();
	for (words::iterator it = result.begin(); it != result.end(); it++){
		cout<<*(it)<<endl;
	}
}

int main(){
//#define __LOCAL__
#ifdef __LOCAL__
	freopen("a.in", "r", stdin);
	freopen("a.out", "w", stdout);
#endif // __LOCAL__
	solve();
    return 0;
}
{% endhighlight %}
