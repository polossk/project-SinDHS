---
layout: post
title: "[比赛记录] Codeforces Round #233 (Div. 2)"
date: 2014-03-02 03:34:48 +0800
categories: contest solution
tags: codeforces
---
# A. Pages

这么简单的题目还需要解释那么多么？

{% highlight cpp %}
/****
    *@PoloShen
    *Title:A
    */
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
using namespace std;

int n, p, k;

void solve(){
    bool first = 1;
    if (p - k > 1) { printf("<<"); first = 0;}
    for (int i = 1; i <= n; i++){
        if (i == p)
        {
            if (first){ first = 0; printf("(%d)", p); }
            else printf(" (%d)", p);
        }
        else if (p - k <= i && i <= p + k){
            if (first){ first = 0; printf("%d", i); }
            else printf(" %d", i);
        }
        else continue;
    }
    if (p + k < n) printf(" >>n");
    else printf("n");
}

int main(){
    while (cin >> n >> p >> k) solve();
    return 0;
}{% endhighlight %}

# B. Red and Blue Balls

竟然和彬哥想到一块了，二进制表示然后直接用 2^n - 1 减去当前状态的数就行。

因为这个转换等效与二进制加1的计算。（R为1，B为0）

嗯，当然注意是栈，所以RBBRB = 01001（2），换句话说就是换一下顺序。

然后那个n的范围比较大，所以就用long long。

{% highlight cpp %}
/****
    *@PoloShen
    *Title:B
    */
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long int64;
int n;
int64 bi[55];
int64 a, b;
void solve(){
    a = bi[n] - 1;
    b = 0;
    char str[55];
    cin >> str;
    for (int i = 0; i < n; i++){
        if (str[i] == 'R') b += bi[i];
    }
    cout << a - b << endl;
}

int main(){
    bi[0] = 1;
    for (int i = 1; i < 55; i++){
        bi[i] = bi[i - 1] * 2;
    }
    while (cin >> n) solve();
    return 0;
}
{% endhighlight %}

# C. Cards

不一定能讲清楚，大概就是这样搞：

把所有的o分成i堆，其中，除了第一个堆以外的所有堆全是只包含一个o的集合

然后就是计算每两个堆之间的x的个数，之后计算当前状态的值。

暴力枚举i即可。rec是特判标志。

比如以下构造：

<blockquote> Input: 20 3<br />

Output: 395<br />

xxoooooooooooooooooooox<br />

</blockquote>

以及这个构造：

<blockquote> Input: 3 20<br />

Output: -97<br />

xxxxxoxxxxxoxxxxxoxxxxx<br />

</blockquote>

还有这个：

<blockquote> Input: 13 20<br />

Output: 23<br />

xxxxxoooooooooooxxxxxoxxxxxoxxxxx<br />

</blockquote>

注意到了么？用贪心的思想去解释的话，那就是要减少连在一起的x，增加连在一起的o，在构造的时候，保证一个长串o（如果存在），然后在分配其他串。

{% highlight cpp %}
/****
    *@PoloShen
    *Title:C
    */
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
using namespace std;

typedef long long int64;
int64 a, b, ans;

void solve(){
    int rec = 1;
    ans = a * a - b * b;
    for (int i = 2; i <= b; i++) {
        if (i - 1 > a) continue;
        int64 x = b % i, y = i - x;
        int64 cost = y * (b / i) * (b / i) + x * (b / i + 1) * (b / i + 1);
        cost = i - 2 - cost + (a - i + 2) * (a - i + 2);
        if (cost > ans) {
            rec = i;
            ans = cost;
        }
    }
    cout << ans << endl;
    if (rec == 1) {
        for (int i = 0; i < a; i++)putchar('o');
        for (int i = 0; i < b; i++)putchar('x');
        return;
    }
    int64 x = b % rec, y = rec - x;
    for (int i = 0; i < rec; i++) {
        if (i < x) {
            for (int j = 0; j < b / rec + 1; j++)putchar('x');
        }
        else {
            for (int j = 0; j < b / rec; j++)putchar('x');
        }
        if (i + 1 < rec) {
            if (i == 0) {
                for (int j = 0; j < a - rec + 2; j++)putchar('o');
            }
            else putchar('o');
        }
    }
    puts("");
}

int main(){
    while (cin >> a >> b) solve();
    return 0;
}
{% endhighlight %}