---
layout: post
title: "[NWPU][2014][SRM][2] 基础题&简单的算法"
date: 2014-07-12 01:23:14 +0800
categories: contest solution
tags: realcombat
---
题目来源[<a href="http://vjudge.net/contest/view.action?cid=49392#overview" target="_blank">Portal</a>]

<table width="264">
<tbody>
<tr>
<td width="95">ID</td>
<td width="81">Origin</td>
<td width="88">Title</td>
</tr>
<tr>
<td>Problem A</td>
<td>POJ 1012</td>
<td>A</td>
</tr>
<tr>
<td>Problem B</td>
<td>POJ 1002</td>
<td>B</td>
</tr>
<tr>
<td>Problem C</td>
<td>UVA 12108</td>
<td>C</td>
</tr>
<tr>
<td>Problem D</td>
<td>UVA 540</td>
<td>D</td>
</tr>
<tr>
<td>Problem E</td>
<td>UVA 136</td>
<td>E</td>
</tr>
</tbody>
</table>

# A

是一个典型的约瑟夫环问题，具体约瑟夫环是什么请自行百度。。。

实现约瑟夫环很简单，最朴素的方法是用一个循环链表就行了，稍稍进化一点的就是用一个数据去维护他，没有什么太难的问题吧。。。

除非你是本地打表做的。。。

看代码吧
{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][SRM][2] A
#       @file         :G:My Source Code[ACM] 训练711 - [NWPU][SRM][2]A.cpp
#       @date         :2014-07-11 19:23
#       @algorithm    :Joseph Loop
******************************************************************************/

#include <cstdio>
#include <cstring>
using namespace std;

int tmp[15], data[15];

void solve()
{
	for (int k = 1; k < 14; k++)
	{
		int res = 1;
		memset(tmp, 0, sizeof(tmp));
		for (int i = 1; i <= k; i++)
        {
            tmp[i] = (tmp[i - 1] + res - 1) % (2 * k - i + 1);
            if (tmp[i] < k) i = 0, res++;
        }
		data[k] = res;
	}
}

int main ()
{
	int k; solve();
	while (~scanf("%d", &k) && k)
		printf("%dn", data[k]);
	return 0;
}{% endhighlight %}

# B

B题题意就是匹配电话号码。怎么搞都可以，因为数据量的缘故。我的做法是hash。就是用一个数组记录这个电话出现了多少次。

具体的看代码吧。
{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][SRM][2] B
#       @file         :G:My Source Code[ACM] 训练711 - [NWPU][SRM][2]B.cpp
#       @date         :2014-07-11 19:23
#       @algorithm    :Hash
******************************************************************************/

#include <cstdio>
#include <algorithm>
using namespace std;

char s[31];

int Hash(){
    int sum=0;
    for (int i = 0, k = 0; k < 7; ++i){
        if(s[i] >= '0' && s[i] <= '9'){
            sum *= 10;
            ++k;
            sum += (s[i] - '0');
        }
        else if(s[i] >= 'A' && s[i] < 'Z'){
            sum *= 10;
            ++k;
            sum += ((s[i] - 'A' - ( s[i] > 'Q' )) / 3 + 2);
        }
    }
    return sum;
}

void solve(){
    int n;
    scanf("%d",&n);
    int data[n];getchar();
    for(int tmp = 0; tmp < n; ++tmp){
        gets(s);
        data[tmp] = Hash();
    }
    sort(data, data + n);
    bool p = 0;
    n--;
    for (int i = 0,num = 1; i < n; i += num = 1){
        while (data[i] == data[i+1]){
            num++;
            i++;
        }
        if (num>1){
            printf("%03d-%04d %dn", data[i] / 10000, data[i] % 10000, num);
            p = 1;
        }
    }
    if (!p) printf("No duplicates.n");
    printf("n");
}

int main(){
    solve();
    return 0;
}{% endhighlight %}

# C

C题是一个很有意思的题目，有10个学生，他们有着自己的一个作息规律（清醒A分钟然后睡B分钟，当前是这个循环的第C分钟），另外就是学生们简直是太机智了，他们在临睡前会检查全部学生中，睡觉的人数是否严格大于清醒的人数，如果这个条件满足，他就会去睡觉。完事问你，整个过程中，有没有10个学生都处于清醒的状态。

根据AB的数据大小，可以推断出每个学生的循环时间在2~10分钟，他们的最小公倍数是4320（lcm(2, 3, 4, 5, 6, 7, 8, 9, 10) = 4320）所以对任何的数据，只要在4320分钟内没有同时醒着的状态，那就表示，他们永远不会有这个状态。反之则将最小的那个输出。

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][SRM][2] C
#       @file         :G:My Source Code[ACM] 训练711 - [NWPU][SRM][2]C.cpp
#       @date         :2014-07-11 19:23
#       @algorithm    :Simulation
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;

int n, tt;
int a[15], b[15], c[15];
const int MaxR = 2520;

void solve()
{
    for (int i = 0; i < n; i++)
        cin >> a[i] >> b[i] >> c[i];
    int ans = 1;
    while (ans < MaxR)
    {
        int awake = 0, sleep = 0;
        for (int i = 0; i < n; i++)
            awake += (c[i] <= a[i]);
        sleep = n - awake;
        if (sleep == 0) break;
        else
        {
            for (int i = 0; i < n; i++)
            {
                c[i]++;
                if (c[i] == a[i] + b[i] + 1) c[i] = 1;
                if (c[i] == a[i] + 1 && awake >= sleep) c[i] = 1;
            }
        }
        ans++;
    }
    printf("Case %d: %dn", ++tt, (ans == 2520)? -1: ans);
}

int main(){
    while (cin >> n && n) solve();
    return 0;
}{% endhighlight %}

# D

D题题意及其繁琐，抽象出来的数学模型是一个由队列构成的队列。

所以我们首先建立一个描述团队的队列Q，Q中的元素是团队的编号。

其次针对每一个编号再次建立一个队列，表示的是这个团队的排队时的队列。

然后为了查询确定标号的人员到底在那个队列，建立一个数组（我这里用的是映射表）来维护标号与所在团队的关系。

最后直接模拟就行了。

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][SRM][2] D
#       @file         :G:My Source Code[ACM] 训练711 - [NWPU][SRM][2]D.cpp
#       @date         :2014-07-11 19:23
#       @algorithm    :Queue Simulation
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;

int n, tt;
const int MaxT = 1010;


void solve()
{
    map<int, int> team;
    queue<int> group, meber[MaxT];
    printf("Scenario #%dn", ++tt);
    for (int i = 0; i < n; i++)
    {
        int t, x;
        scanf("%d", &t);
        while (t--) { scanf("%d", &x); team[x] = i; }
    }
    while (1)
    {
        int x; char cmd[10];
        scanf("%s", cmd);
        if (cmd[0] == 'S') break;
        else if (cmd[0] == 'D')
        {
            int t = group.front();
            printf("%dn", meber[t].front()); meber[t].pop();
            if (meber[t].empty()) group.pop();
        }
        else if (cmd[0] == 'E')
        {
            scanf("%d", &x); int t = team[x];
            if (meber[t].empty()) group.push(t);
            meber[t].push(x);
        }
    }
    puts("");
}

int main()
{
    //freopen("a.out", "w", stdout);
    while (~scanf("%d", &n) && n) solve();
	return 0 ;
}{% endhighlight %}

# E

丑数的算法我简单的说一下。构造一个生成机：从已经有的丑数中选出一个最小的，然后用这个最小值去乘以2，乘以3，乘以5，再把这些值也加进去。这个做法是优先队列的做法。

另外一种做法更为简单也更为易于理解：我设置三个变量x,y,z来维护下一个用来乘以2，乘以3，乘以5的元素，然后讲最小的加进来，并且维护好x,y,z。

这是动态规划的代码：

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][SRM][1] E
#       @file         :G:My Source Code[ACM] 训练711 - [NWPU][SRM][2]E3.cpp
#       @date         :2014-07-11 19:21
#       @algorithm    :DP
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;

const int root[3] = {2, 3, 5};
int x, y, z;
int res[1505];

inline int min(int a, int b, int c) { return min(a, min(b,c)); }

int UNgenerater(int n)
{
    x = y = z = 1;
    for (int i = 2; i <= n; i++)
    {
        int t1 = 2 * res[x];
        int t2 = 3 * res[y];
        int t3 = 5 * res[z];
        res[i] = min(t1, t2, t3);
        if (res[i] == t1) x++;
        if (res[i] == t2) y++;
        if (res[i] == t3) z++;
    }
    return res[n];
}

int main()
{
    res[0] = res[1] = 1;
    cout << "The 1500'th ugly number is " << UNgenerater(1500) << "." << endl;
    return 0;
}{% endhighlight %}

这是优先队列的代码：

{% highlight cpp %}
/*****************************************************************************
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :[NWPU][SRM][1] E
#       @file         :G:My Source Code[ACM] 训练711 - [NWPU][SRM][2]E3.cpp
#       @date         :2014-07-11 19:21
#       @algorithm    :DP
******************************************************************************/

#include <bits/stdc++.h>
using namespace std;

const int root[3] = {2, 3, 5};
int x, y, z;
int res[1505];

inline int min(int a, int b, int c) { return min(a, min(b,c)); }

int UNgenerater(int n)
{
    x = y = z = 1;
    for (int i = 2; i <= n; i++)
    {
        int t1 = 2 * res[x];
        int t2 = 3 * res[y];
        int t3 = 5 * res[z];
        res[i] = min(t1, t2, t3);
        if (res[i] == t1) x++;
        if (res[i] == t2) y++;
        if (res[i] == t3) z++;
    }
    return res[n];
}

int main()
{
    res[0] = res[1] = 1;
    cout << "The 1500'th ugly number is " << UNgenerater(1500) << "." << endl;
    return 0;
}{% endhighlight %}
