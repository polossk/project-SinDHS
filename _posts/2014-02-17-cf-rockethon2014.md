---
layout: post
title: "[比赛记录] Codeforces Rockethon 2014"
date: 2014-02-17 17:19:15 +0800
categories: contest solution
tags: codeforces
---
# A. Genetic Engineering

英语弱，简直是硬伤。。。读了半天才读懂题。其实就一序列，比方说GTTAAAG，分解成G1 T2 A3 G1，然后所有的偶数项，比如T2，都必须增加一个以变成奇数项。换句话说，就是求这个序列中偶数子列的个数。

{% highlight cpp %}
/****
	*@PoloShen
	*Title:D1
	*/
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <complex>
using namespace std;

#include <vector>
#include <list>
#include <stack>
#include <deque>
#include <queue>

typedef complex<int> point;

#define x real()
#define y imag()

struct Shu{
    int xbg, ybg;
    int length;
    point getmidViaShu(){
        return (xbg, double(length / 2.0) + ybg);
    }
};

struct Hen{
    int xbg, ybg;
    int length;
    point getmidViaShu(){
        return (double(length / 2.0) + xbg, ybg);
    }
};

inline point getCross(Shu s, Hen h){ point p(s.xbg, h.ybg); return p; }

Shu data1[1005];
Hen data2[1005];

int n, m;

void solve(){
    for (int i = 0; i < n; i++){
        scanf("%d%d%d", &data1[i].xbg, &data1[i].ybg, &data1[i].length);
    }
    for (int i = 0; i < m; i++){
        scanf("%d%d%d", &data2[i].xbg, &data2[i].ybg, &data2[i].length);
    }
    int ans = 0;
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            point st = getCross(data1[i], data2[j]);
            int temp = data1[i].length;
            int stshuup = data1[i].ybg + data1[i].length - st.y;
            if (stshuup < 0) continue;
            else {
                int stshudown = st.y - data1[i].ybg;
                if (stshudown < 0) continue;
                else {
                    temp = min(stshudown, stshuup);
                    int sthenleft = st.x - data2[j].xbg;
                    if (sthenleft < 0) continue;
                    else {
                        temp = min(temp, sthenleft);
                        int sthenright = data2[j].xbg + data2[j].length - st.x;
                        if (sthenright < 0) continue;
                        else {
                            temp = min(temp, sthenright);
                            ans = max(ans, temp);
                        }
                    }
                }
            }
        }
    }
    cout << ans << endl;
}

int main(){
    while (cin >> n >> m) solve();
    return 0;
}{% endhighlight %}

# B. Word Folding

英语渣。。。其实就是把一个字符串搞成一层一层，问最多的层数。

{% highlight cpp %}
/****
    *@PoloShen
    *Title:B
    */
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
using namespace std;
const int N = 1020;
const int M = 400005;
string s;
int a[N], ans, len;
int vis[N];
struct node
{
    int pos,ans;
    node(int a=0,int b=0):pos(a),ans(b) {}
};
int dfs(int x)
{
    if(vis[x])return vis[x];
    for(int i = x+1; i < len; i+=2)if(s[x]==s[i])
            vis[x] = max(dfs(i),vis[x]);
    vis[x] ++;
    return vis[x];
}
int main()
{
    int i, j, n;
    while(getline(cin, s))
    {
        memset(vis, 0, sizeof(vis));
        len = s.size();
        ans = 1;
        for(i=0; i<len; i++)if(vis[i]==false)ans = max(ans,dfs(i));
        printf("%dn",ans);
    }
    return 0;
}
{% endhighlight %}

# D1. Supercollider
这个主要看在数据量小的面子上，过了。O(mn)的复杂度。。。就是暴力去解。选一个横，选一个竖，求交点，求可行的距离，然后更新答案。

D2的正解是二分。

{% highlight cpp %}
/****
    *@PoloShen
    *Title:D1
    */
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <complex>
using namespace std;

#include <vector>
#include <list>
#include <stack>
#include <deque>
#include <queue>

typedef complex<int> point;

#define x real()
#define y imag()

struct Shu{
    int xbg, ybg;
    int length;
    point getmidViaShu(){
        return (xbg, double(length / 2.0) + ybg);
    }
};

struct Hen{
    int xbg, ybg;
    int length;
    point getmidViaShu(){
        return (double(length / 2.0) + xbg, ybg);
    }
};

inline point getCross(Shu s, Hen h){ point p(s.xbg, h.ybg); return p; }

Shu data1[1005];
Hen data2[1005];

int n, m;

void solve(){
    for (int i = 0; i < n; i++){
        scanf("%d%d%d", &data1[i].xbg, &data1[i].ybg, &data1[i].length);
    }
    for (int i = 0; i < m; i++){
        scanf("%d%d%d", &data2[i].xbg, &data2[i].ybg, &data2[i].length);
    }
    int ans = 0;
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            point st = getCross(data1[i], data2[j]);
            int temp = data1[i].length;
            int stshuup = data1[i].ybg + data1[i].length - st.y;
            if (stshuup < 0) continue;
            else {
                int stshudown = st.y - data1[i].ybg;
                if (stshudown < 0) continue;
                else {
                    temp = min(stshudown, stshuup);
                    int sthenleft = st.x - data2[j].xbg;
                    if (sthenleft < 0) continue;
                    else {
                        temp = min(temp, sthenleft);
                        int sthenright = data2[j].xbg + data2[j].length - st.x;
                        if (sthenright < 0) continue;
                        else {
                            temp = min(temp, sthenright);
                            ans = max(ans, temp);
                        }
                    }
                }
            }
        }
    }
    cout << ans << endl;
}

int main(){
    while (cin >> n >> m) solve();
    return 0;
}
{% endhighlight %}