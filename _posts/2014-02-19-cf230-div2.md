---
layout: post
title: "[比赛记录] Codeforces Round #230 (Div. 2)"
date: 2014-02-19 01:15:44 +0800
categories: contest solution
tags: codeforces
---
# A. Nineteen

该死的字符串，好生生的你为啥要认准那个nineteen不放！

一开始题意没读懂，WA两遍，比赛完了想了想试着再hash一下行不行，然后就过了=。=

你妹的，早点过就不会降rank了！
{% highlight cpp %}
/****
    *@PoloShen
    *Title:A
    */
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <string>
using namespace std;
int N, M, ans, cnt ;
string s;
int main()
{
    int i, j ;
    getline(cin, s);
    N = s.size();
    ans = N;
    for (i = 0, cnt = 0; i < N; i++)
        if (s[i] == 'n') cnt++;
    ans = min(ans, (cnt - 1) / 2);
    for (i = 0, cnt = 0; i < N; i++)
        if (s[i] == 'i') cnt++;
    ans = min(ans, cnt);
    for (i = 0, cnt = 0; i < N; i++)
        if (s[i] == 't') cnt++;
    ans = min(ans, cnt);
    for (i = 0, cnt = 0; i < N; i++)
        if (s[i] == 'e') cnt++;
    ans = min(ans, cnt / 3);
    cout << ans << endl;
    return 0 ;
}
{% endhighlight %}

# B. Three matrices

题目很简单，求一个矩阵的对称矩阵A与反对称矩阵B，使得A+B=W，很简单的题目了。

{% highlight cpp %}
/****
    *@PoloShen
    *Title:B
    */
#include <iostream>
#include <cstdio>
using namespace std;

int W[200][200];
double a[200][200], b[200][200];
int n;

void solve(){
    for (int i=0;i<n;i++){
        for (int j=0;j<n;j++){
            a[i][j] = 0.5 * (W[i][j] + W[j][i]);
            b[i][j] = 0.5 * (W[i][j] - W[j][i]);
        }
    }
    for (int i=0;i<n;i++){
        for (int j=0;j<n-1;j++){
            printf("%.8lf ", a[i][j]);
        }
        printf("%.8lfn", a[i][n-1]);
    }
    for (int i=0;i<n;i++){
        for (int j=0;j<n-1;j++){
            printf("%.8lf ", b[i][j]);
        }
        printf("%.8lfn", b[i][n-1]);
    }
}

int main(){
    cin >> n;
    for (int i=0;i<n;i++){
        for (int j=0;j<n;j++){
            cin>>W[i][j];
        }
    }
    solve();
    return 0;
}
{% endhighlight %}

# C. Blocked Points

首先，请允许我对那些牛逼的找规律帝们进行一番可耻的鄙视！

好吧我们来翻译一下题目意思。大概是讲，有一个在二维平面上的整数点之间的性质，4连通性，姑且这么说吧。有如下判定定理：

<ol>
<li>两个整数点的欧氏距离为1；</li>
<li>A与C连通，C与B连通，则A与B连通。</li>
</ol>

然后告诉你一个范围n，求这个范围下的从范围n开始，到原点方向所有的四连通点的个数。

这个问题抽象出来就是很著名的圆内整点问题。


然后我们就可以发现，只计算一次坐标轴上的点，每一个象限内的点的分布满足数列0, 1, 2, 4, 5, 7, 8, 9, 11, 12, 14, 15, ...

<a style="color: #ff9900;" href="http://oeis.org/A001951" target="_blank">点我传送门</a>

oh no！答案不会是这个乘四吧！特判n=0。

{% highlight cpp %}
/****
    *@PoloShen
    *Title:C
    */
#include <iostream>
#include <cmath>
using namespace std;

int main(){
    int n;
    while (cin >> n){
        int x = n * sqrt(double(2));
        if (n == 0) cout << 1 << endl;
        else cout << x * 4 << endl;
    }
    return 0;
}
{% endhighlight %}

# D. Tower of Hanoi

DP<br />
DP[n][from][via][to]，表示在n的条件下从状态"from"经过状态"via"到状态"to"。<br />
DP[1][from][via][to] = min( t[from][to], t[from][via] + t[via][to]);<br />
t[][]是输入的矩阵。<br />
Dim num1 = DP[n-1][from][to][via] + DP[n-1][via][from][to] + t[from][to];<br />
Dim num2 = 2 * DP[n-1][from][via][to] + t[from][via] + DP[n-1][to][via][from] + t[via][to];<br />
DP[n][from][via][to] = min( num1, num2);

{% highlight cpp %}
/****
	*@PoloShen
	*Title:D
	*/
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long int64;
const int sz = 45;
int t[sz][sz];
int64 dp[sz][sz][sz][sz];

int64 getDP(int n, int from, int via, int to)
{
    if (n==1) return min(t[from][to], t[from][via] + t[via][to]);
    int64& ret = dp[n][from][via][to];
    if(ret != -1) return ret;
    ret = getDP(n-1, from, to, via) + getDP(n-1, via, from, to) + t[from][to];
    ret = min(ret, 2 * getDP(n-1, from, via, to) + t[from][via] + getDP(n-1, to, via, from) + t[via][to]);
    return ret;
}

int main()
{
    int n, m;
    memset(dp, -1, sizeof(dp));
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            scanf("%d", &t[i][j]);
    scanf("%d", &n);
    cout << getDP(n, 0, 1, 2) << endl;
    return 0;
}{% endhighlight %}
