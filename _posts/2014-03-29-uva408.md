---
layout: post
title: "UVa 408 Uniform Generator 数论 基础数论上手题大清理（5）"
date: 2014-03-29 22:18:48 +0800
categories: contest math
tags: acmicpc uva numbertheory
---
题目地址<a title="UVa 408" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=100&page=show_problem&problem=349" target="_blank">-></a>

题目是说，对一个密码生成系统，也就是给一个Step，给一个Mod，问能不能把所有的[0,Mod)的数字取一遍。

我们这么考虑，假设这个密码生成系统的循环节大小为w，也就是第w个数就是Step本身，那么把这些w个数由小到大进行排列，就会得到一个新的序列。我们定义这个序列是{Cn}，这个序列中，我们假设每两个相邻的数字间隔为di，由于Step一定，所以所有di都相同，我们假设这个间隔为D。其次，我们令d = gcd(Step, Mod)。另外，对任意的两个序列中的数字都可以表示为i * Step % Mod和j * Step % Mod，他们的最大公约数同样为d。下面我们假设D不等于d，这个时候，我们有（i - j）* Step % Mod = D <> d。

显然d是Step的因数，所以当且仅当（i == j）的时候，才会有D不等于d。显然这和我们的假设相邻的两个元素矛盾了，所以D与d相同。

所以，我们只要判断Step和Mod的最大公约数是否为1就行了。如果是1，那么就一定会生成所有的数字，因为相邻的元素间隔为1，自然可以遍历。如果不是1，那么生成的序列就是以他们最大公约数为间隔的序列。

Code Here
{% highlight cpp %}
//408
#include <cstdio>
int gcd(int a, int b)
{
	return (b == 0)? a: gcd(b, a % b);
}
int main(){
	int n, m;
	while (scanf("%d%d", &n, &m) != EOF){
		printf("%10d%10d", n, m);
		if (gcd(n, m) == 1)
			printf("    Good Choicenn");
		else
			printf("    Bad Choicenn");
	}
	return 0;
}{% endhighlight %}
