---
layout: post
title: "HDU 4856 西安邀请赛J题 状态压缩DP"
date: 2014-05-26 23:17:29 +0800
categories: contest dp
tags: acmicpc hdu realcombat szipdp
---
题目地址<a title="HDU 4856" href="http://acm.hdu.edu.cn/showproblem.php?pid=4856" target="_blank">-></a>

题意是说，一个图，有些点是封闭的（在图中用'#'表示），然后有一些传送门，就是很native的那种从一个点进去从一个点出来的那种超时空玩意。然后问，随便你从哪个点作为起点都行，但是要求，最后的遍历所有的这些传送门（ 题目中叫'tunnel'）所消耗的时间最小。输出最小时间。

我和队友的建图思路不怎么一样，他们是直接就在原图上建图，我是另外的以那个tunnel为图中的节点来建的图。但是大致思路都是一样的。先Floyd跑一个每个点的最短路，然后状态压缩TSP搞出结果。

队友的代码WA了两个代码细节，我的则没能调试出来。。。后来比赛完又写了一个，不知道对不对，因为学校的OJ没有加题，所以就没有测。。。

Code Here
{% highlight cpp %}
/****
	*@author    Shen
	*@title     西安邀请赛J
	*/

#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;

const int maxN = 25;
const int maxM = 21;
const int inf  = 500000000;
int n, m, tot, a[maxN * maxN][maxN * maxN];
int cost[maxM][maxM], f[maxM][1 << maxM];
bool bar[maxN][maxN];
char str[maxN];
pair <int, int> tunnel[maxM];

inline int encode(int x, int y)
{
	return (x - 1) * n + y;
}

void DataScanner()
{
	for (int i = 1; i <= n; i++) bar[i][i] = false;
	tot = n * n;
	for (int i = 1; i <= n; i++)
	{
		scanf("%s", str + 1);
		for (int j = 1; j <= n; j++)
		{
			if (str[j]=='#') bar[i][j] = true;
			else bar[i][j] = false;
		}
	}
	int x1, x2, y1, y2;
	for (int i = 1; i <= m; i++)
	{
		scanf("%d%d%d%d",  &x1,  &y1,  &x2,  &y2);
		tunnel[i] = make_pair(encode(x1, y1), encode(x2, y2));
	}
}

void Build()
{
    for (int i = 1; i <= tot; i++)
		for (int j = 1; j <= tot; j++)
			a[i][j] = inf;
	for (int i = 1; i <= tot; i++)
		a[i][i] = 0;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			if (bar[i][j]) continue;
			if (j < n && !bar[i][j + 1])
                a[encode(i, j)][encode(i, j + 1)] = a[encode(i, j + 1)][encode(i, j)] = 1;
			if (i < n && !bar[i + 1][j])
                a[encode(i, j)][encode(i + 1, j)] = a[encode(i + 1, j)][encode(i, j)] = 1;
		}
	}
}

void Floyd()
{
	for (int k = 1; k <= tot; k++)
		for (int i = 1; i <= tot; i++)
			for (int j = 1; j <= tot; j++)
				a[i][j] = min(a[i][j], a[i][k]+a[k][j]);
}

void DP()
{
	for (int i = 1; i <= m; i++)
		for (int j = 1;j <= m;j++)
			if (i == j) continue;
			else
                cost[i][j] = a[tunnel[i].second][tunnel[j].first];
	for (int i = 1; i <= m; i++)
		for (int j = 0; j<(1 << m); j++)
			f[i][j] = inf;
	for (int i = 1; i <= m; i++)
		f[i][1 << (i-1)] = 0;
	for (int mask = 0; mask < (1 << m); mask++)
	{
		for (int i = 1; i <= m; i++)
		{
			if (!(mask & (1 << (i - 1)))) continue;
			for (int j = 1;j <= m;j++)
			{
				if (mask & (1 << (j - 1))) continue;
				f[j][mask ^ (1 << (j - 1))] = min(f[j][mask ^ (1 << (j - 1))], f[i][mask] + cost[i][j]);
			}
		}
	}
	int ans = f[1][(1 << m)-1];
	for (int i = 2; i <= m; i++) ans = min(ans, f[i][(1 << m)-1]);
	if (ans >= inf) printf("-1n");
	else printf("%dn", ans);
}

void solve()
{
    DataScanner();
    Build();
    Floyd();
    DP();
}

int main()
{
	while (~scanf("%d%d", &n, &m))
        solve();
	return 0;
}{% endhighlight %}
