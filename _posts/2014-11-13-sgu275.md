---
layout: post
title: "SGU 275 To xor or not to xor 高斯消元"
date: 2014-11-13 17:06:11 +0800
categories: contest math
tags: acmicpc sgu gausse
---
题目地址<a title="SGU 275" href="http://acm.sgu.ru/problem.php?contest=0&problem=275" target="_blank">-></a>

如果单纯的用枚举法，其时间复杂度是O(2^n)，这明显并不是一个优秀的算法，在空间上和时间上都达不到我们的要求。所以我们应当换个思维去思考这个问题。

因为题目要求最后的异或值最大，这就引导着我们去思考如何才能达到这个目标。若最后的异或结果更大，那么在对应的数的二进制表示下，必然有一个较高位的值等于 1。如此一来，就可以尽量满足选取的数的最终异或结果是一个较大的数了。

虽然大概的思路，但是解决方案又应该是什么呢？如何才能判断这个数到底有没有被选中呢？

如果此时，解决方案仍然限制在01规划上，那必然反映了对目标理解的不恰当。注意，这个目标的要求是，使得较高位的值最后的异或结果1。这样的思路必然引导着我们需要将所给的数用二进制表示出来。考虑到数据的规模，实际上每个数可以用一个63维的向量来表示。

$$\begin{aligned}a_i &= (\delta_{i0}, \delta_{i0}, \cdots \delta_{i,62})^{T}, \\a_i &= 2^{0} \times \delta_{i0} + 2^{1} \times \delta_{i1} + \cdots +2^{62} \times \delta_{i,62}.\end{aligned}$$

其中

$$\delta_{ij} =\left\{\begin{aligned}1\\0\end{aligned}\right.,$$

然后就是类似01规划那样建立一个方程组了，简而言之，用x_i表示第i号元素有没有被选中。对于结果，因为我们期待最后的结果是最大的值（如果是全为1的向量那自然更好），所以方程的右边设置为1。 从而，得到一个方程组。

$$Ax = b$$,

其中

$$A=\left({\begin{array}{*{20}{c}}\delta_{10} & \delta_{20} & \cdots & \delta_{n0} \\\delta_{11} & \delta_{21} & \cdots & \delta_{n1} \\\vdots & \vdots & \ddots & \vdots \\\delta_{1,62} & \delta_{2,62} & \cdots & \delta_{n,62} \\\end{array}}\right),x = \left({\begin{array}{*{20}{c}}{x_{1}}\\{x_{2}}\\\vdots \\{x_{n}}\end{array}}\right),b = \left({\begin{array}{*{20}{c}}{1}\\{1}\\\vdots \\{1}\end{array}}\right).$$.

剩下的事情就是消元工作了！

在消元的同时，仍然需要考虑几个问题。由于在事先规定时，将较高位放在了最下面，所以应当从下往 上进行消元。同时注意，如果在消元过程中，出现了没有被控制的自由变元，这说明改行的结果一定为1，并且这个自由变元控制改行的方程。此时应该从这一行开始，往上依次消去该自由变元。具体的操作就是逐 一异或。

如果在消元过程中第k行中没有可以用来控制方程的变量，则需要分析此时的$$b_k$$，如果$$b_k = 0$$，说明这一行可以达到我们所期待的要求（异或后，该位上的值为1），这个时候就要累加答案。相反，如果$$b_k = 1$$， 说明这一行无解（很明显的结论，比如数列为 14, 11, 3, 6 时，第 63 个方程显然出现了 0 = 1 这一情形），这个时候就应该不再考虑该情形，直接跳过即可。

由于在消元过程当中已经实现了累加答案这一操作，故之后只需将答案输出即可。 对这个方法进行分析，至多有 n 个元，则时间复杂度为 $$O(N^3)$$，空间复杂度$$ O(N^2)$$（证明略）。明显比其他方法迅速很多。

Code Here
{% highlight cpp %}
// <!-- encoding UTF-8 --!>
/*****************************************************************************
*                      ----Stay Hungry Stay Foolish----                      *
*    @author    :   Shen                                                     *
*    @name      :   sgu 275                                                  *
*****************************************************************************/
// 人一我百，人十我万！追逐青春的梦想，怀着自信的心，永不放弃！
//#pragma GCC optimize ("O2")
//#pragma comment(linker, "/STACK:1024000000,1024000000")

//#include <bits/stdc++.h>
#include <map>
#include <list>
#include <queue>
#include <stack>
#include <cmath>
#include <vector>
#include <string>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long int64;
template<class T>inline bool updateMin(T& a, T b){ return a > b ? a = b, 1: 0; }
template<class T>inline bool updateMax(T& a, T b){ return a < b ? a = b, 1: 0; }
inline int    nextInt() { int x; scanf("%d", &x); return x; }
inline int64  nextI64() { int64  d; cin >> d; return d; }
inline char   nextChr() { scanf(" "); return getchar(); }
inline string nextStr() { string s; cin >> s; return s; }
inline double nextDbf() { double x; scanf("%lf", &x); return x; }
inline int64  nextlld() { int64 d; scanf("%lld", &d); return d; }
inline int64  next64d() { int64 d; scanf("%I64d",&d); return d; }

const int MAXN = 105;

int n, a[MAXN][MAXN];
long long t, bits[MAXN], ans;

inline void solve()
{
    ans = 0;
    for (int i = 0; i < n; i++)
    {
        t = nextI64();
        for (int j = 0; j < 63; j++)
            a[j][i] = bool(t & bits[62 - j]);
    }
    for (int i = 0; i < 63; i++)
        a[i][n] = 1;
    for (int i = 0; i < 63; i++)
    {
        int x = -1;
        for (int j = 0; j < n; j++) if (a[i][j])
        {
            x = j;
            break;
        }
        if (x == -1 && a[i][n] == 0) // free x
            ans += bits[62 - i];
        else if (x != -1) // elimination
        {
            ans += bits[62 - i];
            for (int k = i + 1; k < 63; k++) if (a[k][x])
                for (int j = 0; j <= n; j++)
                    a[k][j] ^= a[i][j];
        }
    }
    cout << ans << endl;
}

int main()
{
    bits[0] = 1LL;
    for (int i = 1; i < 63; i++)
        bits[i] = bits[i - 1] << 1;
    while (~scanf("%d", &n)) solve();
    return 0;
}{% endhighlight %}
