---
layout: post
title: "UVa 401 Palindromes 简单字符串问题"
date: 2013-10-23 16:58:38 +0800
categories: contest string
tags: acmicpc uva basicstring
---
题目地址<a title="UVa 401" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=96&page=show_problem&problem=342" target="_blank">-></a>

题目自身的意思非常简单，就是判断一个字符串的两种性质：回文和轴对称。我的做法是分别判断回文和轴对称，设置两个逻辑型变量，然后根据反馈的结果输出标志语。对于判断轴对称，我的做法是从字符串末尾开始生成一个“镜像”，如果镜像与源字符串是相同的，那么就是轴对称的。

好早写的了，今天拿出来看看。

Code Here

{% highlight cpp %}
/****
	*@Polo-shen
	*
	*/
#include <iostream>
#include <string>
#include <cstring>
#include <cstdio>
#include <cctype>

using namespace std;
typedef long long int64;

#define DBG 0
#define ShowLine DBG && cout<<__LINE__<<">>| "
#define dout DBG && cout<<__LINE__<<">>| "
#define write(x) #x" = "<<(x)<<", "
char s1[27]="A   3  HIL JM O   2TUVWXY5";
char s2[10]="1SE Z  8 ";
int main(){
    char s[30];
    while (gets(s)){
        int pal=1,mir=1;
        int i,n=strlen(s);
        for (i=0;i<n;i++)
            if (s[i]!=s[n-i-1]){
                pal=0;
                break;
            }
        for (i=0;i<n;i++)
            if (isalpha(s[i])&&s[n-1-i]!=s1[s[i]-'A']){
                mir=0;
                break;
            }
            else if (isdigit(s[i])&&s[n-1-i]!=s2[s[i]-'1']){
                mir=0;
                break;
            }
        for (i=0;i<n;i++)
            if(s[i]=='0')s[i]='O';
        if (pal&&mir)printf("%s -- is a mirrored palindrome.n",s);
        else if (mir)printf("%s -- is a mirrored string.n",s);
        else if (pal)printf("%s -- is a regular palindrome.n",s);
        else printf("%s -- is not a palindrome.n",s);
        printf("n");
    }
    return 0;
}{% endhighlight %}
