---
layout: post
title: "[比赛记录] Codeforces Round #238 (Div. 2)"
date: 2014-03-23 02:47:57 +0800
categories: contest solution
tags: codeforces
---
# A. Gravity Flip

直接快排，不需要太多解释我觉得。。。

{% highlight cpp %}
/****
    *@PoloShen
    *Title:A
    */

//#pragma comment(linker, "/STACK:1024000000,1024000000")
//#pragma GCC optimize ("O2")

#include <iostream>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

#include <vector>
#include <list>
#include <stack>
#include <deque>
#include <queue>

int n;
vector<int> a;
void solve(){
    for (int i = 0; i < n; i++){
        int tmp; cin >> tmp;
        a.push_back(tmp);
    }
    sort(a.begin(), a.end());
    for (int i = 0; i < n - 1; i++)
        cout << a[i] << " ";
    cout << a[n - 1] << endl;
}

int main(){
    cin >> n;
    solve();
    return 0;
}
{% endhighlight %}

# B. Domino Effect

模拟题，看情况考虑和代码质量了。本人英语渣，看题半天=。=

事实证明多读题有助于AC。。。

{% highlight cpp %}
/****
    *@author PoloShen
    *Title:
    */

//#pragma comment(linker, "/STACK:1024000000,1024000000")
//#pragma GCC optimize ("O2")

#include <iostream>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

#include <vector>
#include <list>
#include <stack>
#include <deque>
#include <queue>

typedef long long int64;

char s[5005];
int n;
void solve()
{
int ans=0,flag=0,sum=0;
    for(int i=1;i<=n;i++)
    {
        if(s[i]=='L'&&flag!=1)
        {
            sum=0;
            continue;
        }
        if(s[i]=='L'&&flag==1)
        {
            flag=0;
            ans+=sum;
            sum=0;
            continue;
        }
        if(s[i]=='R')
        {
            flag=1;
            int j=i;
            while(i<=n&&(s[i]=='.'||s[i]=='R'))
                i++;
            if(i<=n&&(i-j)%2==0&&s[i]=='L')
                ans++;
            continue;
        }
        sum++;
    }
    ans+=sum;
    printf("%dn",ans);
}
int main()
{
    scanf("%d",&n);
    scanf("%s",s+1);
    solve();
    return 0;
}
{% endhighlight %}

# C. Unusual Product

怎么说呢？这是一道极好极好的思维题。

首先先看一下这个矩阵的“新内积”，也就是把矩阵分解成一个一个的列向量和行向量，随后在分别求这些向量的内积，然后再求其和。

接着请看这个数学模型的基础——在模2的条件下。

最后注意一下这个操作，翻转，也就是0变1，1变0。

模2，我自然的就想到了布尔型bool，这个类型的变量只有两个值，1和0，也就是真和否。

那么对于这个意义下的乘法，就只有 1 * 1 = 1，其余的计算均为零。

对于这个意义下的加法，就有 1 + 1 = 0；0 + 1 = 1；1 + 0 = 1；0 + 0 = 0。

对于这个操作“翻转”，其实也就是逻辑运算中的 非运算了。

这时候我给出断言，在计算矩阵的这个代数系统下的内积时，其内积等于矩阵的迹（主对角线各元素之和，也是其全体特征值的和）。<br />
为什么呢？

而且因为这个是在模2的系统下，所以对任意的一个数x，都有2 * x = 0

万事俱备了！

那么如何求解呢？

注意实际上反转就是更改了对角线上的一个数，那么其实更改哪一个行，哪一个列都无关紧要，只要翻转一次，那么就等效于对角线上的一个元素自身+1。注意到乘法表，+1运算其实就是逻辑运算中的非运算，所以每当进行到对矩阵修改时，都要对修改前的答案ans进行一次取反运算。

所以提前进行一个预处理就行了。

综合时间复杂度O(n) - O(1)

{% highlight cpp %}
/****
    *@PoloShen
    *Title:C
    */

#include <iostream>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

#include <vector>
#include <list>
#include <stack>
#include <deque>
#include <queue>

int n;
bool M[1005][1005];
int q;
bool ans = 0;

void setMatrix(){
    for (int i = 0; i < n; i++)
        if (M[i][i])
            ans = !ans;
}

void CallEdit(){
    int i; scanf("%d", &i);
    ans = !ans;
}

void CallPuts(){
    printf("%d", ans);
}

void solve(){
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            scanf("%d", &M[i][j]);
    setMatrix();
    scanf("%d", &q);
    while (q--){
        int flag;
        scanf("%d", &flag);
        switch (flag){
            case 1:{ CallEdit(); break; }
            case 2:{ CallEdit(); break; }
            case 3:{ CallPuts(); break; }
            default: break;
        }
    }
    printf("n");
    return;
}

int main(){
    solve();
    return 0;
}
{% endhighlight %}
