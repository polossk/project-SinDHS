---
layout: post
title: "HDU 4850 西安邀请赛D题 字符串生成题 深搜"
date: 2014-05-26 23:28:40 +0800
categories: contest serach
tags: acmicpc hdu realcombat dfs
---
题目地址<a title="HDU 4850" href="http://acm.hdu.edu.cn/showproblem.php?pid=4850" target="_blank">-></a>

题意是说，求一个字符串，他的所有长度超过4的子串都是唯一的。

然后我当时是想aaaa, baaa, caaa, daaa...这样巴拉巴拉一直生成下去的，后来发现真的是想的太天真了，因为前面的两个长度为4的子串（“aaaabaaa”）的存在，直接封杀了3个子串（“aaab”, “aaba”, "abaa”）。然后我就想记录状态去试着暴力去跑一个生成机。其实也很简单，就是四位一生成的原理，对所有的都尝试，不断地深搜，并且记录状态。

然后竟然过了！不可思议。

Code Here
{% highlight cpp %}
/****
	*@author    Shen
	*@title     西安邀请赛D
	*/

#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const char* alpha = "abcdefghijklmnopqrstuvwxyz";
const int asz = 26;
const int maxN = 500000;
int maxS, len, s, state[4 * asz + 13];
char result[maxN];

int dfs(int curr, int prev)
{
    if (len >= maxN) return 0;
    if (curr > 4)//catch char
    {
        if (4 % prev == 0)
        {
            for (int i = 1; i <= prev; i++)
            {
                result[len++] = state[i];
                if (len >= maxN) break;
            }
        }
    }
    else
    {
        int stateID = state[curr - prev];
        state[curr] = stateID;
        dfs(curr + 1, prev);
        for (int i = stateID + 1; i < 26; i++)
        {
            state[curr] = i;
            dfs(curr + 1, curr);
        }
    }
    return 0;
}

inline void addStringaaa()
{
    result[len] = result[len + 1] = result[len + 2] = 'a';
    result[len + 3] = '';
    maxS = len + 3;
}

void solve()
{
    if (s > maxS) puts("Impossible");
    else
    {
        for (int i = 0; i < s; i++)
            printf("%c", result[i]);
        puts("");
    }
}

int main()
{
    dfs(1, 1);
    for (int i = 0; i < len; i++)
        result[i] = alpha[result[i]];
    addStringaaa();
    while (~scanf("%d", &s))
        solve();
    return 0;
}{% endhighlight %}
