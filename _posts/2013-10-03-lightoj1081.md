---
layout: post
title: "LightOJ 1081 Square Queries 最后一发二维RMQ问题"
date: 2013-10-03 21:09:02 +0800
categories: contest datastructure
tags: acmicpc lightoj rmq
---
题目地址<a title="LightOJ 1081" href="http://LightOJ.com/volume_showproblem.php?problem=1081" target="_blank">-></a>

这个题目依旧是二维RMQ，不过对内存卡的有点紧。全部用int会MLE，试着用unsigned short会丢失精度导致WA。所以这个题目有两个解决方案：仔细分析问题降低纬度，或者手写17位整数类型int17_t。

# 方案一：

我想到的方法是怎么样能够把数组开的小一些，因为如果用以前的模板按照模板标准开dp数组，我要开一个 500 * 500 * 9 * 9 的数组，也就是20250000=。=

简直是凶残， 20,250,000 的数据，太庞大了有没有！

超内存有没有！MLE！！！

但是如果能够降一维（其实当时我觉得是要能降一点点就够了=_=），但问题是怎么降维度？

我们以前讨论的从一维RMQ中的ST算法升级到二维RMQ中的ST算法，运用的是分类分治的方法。[<a title="ZOJ 2859 Matrix Searching 二维RMQ问题" href="http://polossk.com/archives/422" target="_blank">传送门</a>]

既然是运用分类分治的方法把二维的问题分成了垂直划分和水平划分，我们就肯定能用一个简单的综合法把这些划分再还原成原状态，额(⊙o⊙)…有点绕嘴，这样，请好好看看我们的思路：

对于一维RMQ问题，ST算法的思路是二分，相当于

大问题 -> 两个小问题

结合上一维的情况，如果用x轴来表示一维，那么就是

大线段 -> 两个小线段

没错吧。

那么二维RMQ问题呢？如果你选择ST算法迭代ST算法，那么你很可能是走了这条路：

大问题 -> 分类讨论；

结合二维的情况，如果求解一个矩形内的最值，那么就是

大矩形 ->分割！ -> 在x轴的问题，那就在x轴上二分；在y轴的问题，那就在y轴上二分

但实际上我觉得，对于这道题目，因为所有访问的矩形全是正方形！注意全是正方形，所以我觉得这条路也没有错

大问题 ->四个小问题

结合我们的实际问题那就是：

大矩形 ->四个小矩形 -> 综合计算

状态转移方程就是

dp[row][col][k] 表示[row,row+2^k-1] x [col,col+2^k-1] 中的最大值

dp[row][col][k] = max(

dp[row][col][k-1],

dp[row+(1<<(k-1))][col][k-1],

dp[row][col+(1<<(k-1))][k-1],

dp[row+(1<<(k-1))][col+(1<<(k-1))][k-1]

);

注意！这个思想只是因为正方形的访问才能使用！切记切记！

# 方案二：

这个方法是在网上游荡时发现的，真是神一样的方法！原地址：http://www.java123.net/detail/view-349945.html

首先我们很快就会发现数据的大小在0到100000之间（All the integers will be between0 and105），所以这位大牛突发奇想：

--->请看

<table style="color: #000000;" border="1" width="337" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td>数据类型</td>
<td>数据大小</td>
</tr>
<tr>
<td>short</td>
<td>-32768 ~ +32767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>bit + unsigned short</td>
<td>0 ~ 131071</td>
</tr>
</tbody>
</table>
那么如果来一个unsigned int17_t，问题解决！

果然是大神的办法。那么如何实现呢？

同时开

unsigned short dt[501][10][501][10];

bitset<500*10*500*10+10> de;

然后增加函数trans，用于计算数组下标。随后就是模板问题了。

# Code Here

降低纬度：

{% highlight cpp %}
#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
int f_max(int x,int y){return x>y?x:y;}
int f_max(int a,int b,int c,int d){
	return f_max(f_max(a,b),f_max(c,d));
}

int N,Q,num[500][500];
int dp[500][500][10];

void get_data(){
	int i,j,k,l;
	scanf(" %d %d",&N,&Q);
	for(i=0;i<N;i++){
		for(j=0;j<N;j++){
			scanf(" %d",&num[i][j]);
			dp[i][j][0]=num[i][j];
		}
	}
	for(k=1,l=2;l<=N;k++,l<<=1){
		for(i=0;i+l-1<N;i++){
			for(j=0;j+l-1<N;j++){
				dp[i][j][k]=f_max(
								dp[i][j][k-1],
								dp[i+(l>>1)][j][k-1],
								dp[i][j+(l>>1)][k-1],
								dp[i+(l>>1)][j+(l>>1)][k-1]
				);
			}
		}
	}
}
void run(){
	int xi,xj,xl,k,l;
	while(Q--){
		scanf(" %d %d %d",&xi,&xj,&xl);xi--;xj--;
		k=log(xl*1.0)/log(2.0);l=1<<k;
		printf("%dn",f_max(
						dp[xi][xj][k],
						dp[xi][xj+xl-l][k],
						dp[xi+xl-l][xj][k],
						dp[xi+xl-l][xj+xl-l][k]
						)
			);
	}
}
void solve(int i){
	get_data();
	printf("Case %d:n",i);
	run();
	return;
}
int main(){
	int i=0,t;
	scanf("%d",&t);
	while (t--){
		solve(++i);
	}
	return 0;
}{% endhighlight %}

手写int17_t：

{% highlight cpp %}
#include<cstdio>
#include<algorithm>
#include<vector>
#include<bitset>

using namespace std;

int tr(int i,int j,int k,int l)
{
    return (i-1)*10*500*10+j*500*10+(k-1)*10+l;
}

unsigned short dt[501][10][501][10];
bitset<500*10*500*10+10>de;
int fc[510],n;
void upd(int i,int j,int k,int l,int i2,int j2,int k2,int l2,int i3,int j3,int k3,int l3)
{
    if(de[tr(i2,j2,k2,l2)]==de[tr(i3,j3,k3,l3)])
    {
        de[tr(i,j,k,l)]=de[tr(i2,j2,k2,l2)];
        if(dt[i2][j2][k2][l2]>dt[i3][j3][k3][l3])
            dt[i][j][k][l]=dt[i2][j2][k2][l2];
        else dt[i][j][k][l]=dt[i3][j3][k3][l3];
    }
    else if(de[tr(i2,j2,k2,l2)]>de[tr(i3,j3,k3,l3)])
    {
        dt[i][j][k][l]=dt[i2][j2][k2][l2];
        de[tr(i,j,k,l)]=de[tr(i2,j2,k2,l2)];
    }
    else
    {
        dt[i][j][k][l]=dt[i3][j3][k3][l3];
        de[tr(i,j,k,l)]=de[tr(i3,j3,k3,l3)];
    }
}
void build()
{
    for(int j=0; (1<<j)<=n; ++j)
        for(int i=1; i+(1<<j)-1<=n; ++i)
            for(int l=0; (1<<l)<=n; ++l)
                for(int k=1; k+(1<<l)-1<=n; ++k)
                {
                    if(!l&&j)upd(i,j,k,l,i,j-1,k,l,i+(1<<(j-1)),j-1,k,l);
                    if(l)upd(i,j,k,l,i,j,k,l-1,i,j,k+(1<<(l-1)),l-1);
                }
    fc[1]=0;
    for (int i=2;i<=n;++i)fc[i]=fc[i-1]+((1<<(fc[i-1]+1))<=i);
}

int ty(int i,int j,int k,int l)
{
    return (int(de[tr(i,j,k,l)])<<16)+dt[i][j][k][l];
}

int q1d(int i,int j,int c,int d)
{
    return max(ty(i,j,c,fc[d-c+1]),ty(i,j,d-(1<<fc[d-c+1])+1,fc[d-c+1]));
}

int q2d(int a,int b,int c,int d)
{
    return max(q1d(a,fc[b-a+1],c,d),q1d(b-(1<<fc[b-a+1])+1,fc[b-a+1],c,d));
}

int main()
{
    int T;
    scanf("%d",&T);
    for (int kase=1;kase<=T;kase++)
    {
        de.reset();
        int q;
        scanf("%d%d",&n,&q);
        for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
        {
            int t;
            scanf("%d",&t);
            de[tr(i,0,j,0)]=(t>>16);
            dt[i][0][j][0]=(t&((1<<16)-1));
        }
        build();
        printf("Case %d:n",kase);
        for(int i=1;i<=q;++i)
        {
            int a,b,c;
            scanf("%d%d%d",&a,&b,&c);
            printf("%dn",q2d(a,a+c-1,b,b+c-1));
        }
    }
    return 0;
}{% endhighlight %}
