---
layout: post
title: "UVa 156 Ananagrams 单词排序"
date: 2014-01-10 10:55:19 +0800
categories: contest serach
tags: acmicpc uva basicsearch
---
题目地址<a title="UVa 156" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=98&page=show_problem&problem=92" target="_blank">-></a>

题目意思是说，在一部字典里(就是输入数据)，有一些单词，在我们忽略大小写和单词中的字母顺序的话，可能会出现重复。比方说NotE和Tone，就是一个典型的例子。那么在这个字典中，有多少个没有重复的单词，并且用字典序输出。

求解方法也比较简单，恩，我们把每个单词输入的时候进行预处理，同时保存实际单词和单词内字母按字典序排序的单词，同时保存一个记录变量，用于说明这个单词本身在这个字典中是不是“唯一的”。预处理之后，按照单词内字母按字典序排序的单词进行排序得到新的字典。然后从头到尾扫描一遍字典判断单词是不是唯一的，其实就是判断该单词的前驱与后继是不是相同即可。最后，把那些“唯一的”单词拿出来，用原来输入进去的字符串的排序规则排序，输出即可。时间复杂度O(nlogn)。

说的比较乱，大家看下代码吧。

Code Here

{% highlight cpp %}
/****
	*@PoloShen
	*Title:UVaOJ 156
	*/
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>
#include <cstdio>
using namespace std;

class Word{
public:
	Word():tim(-1){}
	Word(string str){
		ori = str;dic = str;tim = 1;
		transform(dic.begin(), dic.end(), dic.begin(), ::tolower);
		sort(dic.begin(), dic.end());
	}
	string toString(){ return ori; }
	string toDicton(){ return dic; }
	int showTimes(){ return tim; }
	void setTimes(int t){ tim = t; }
	friend bool wcmp(const Word& a, const Word& b);
	friend bool ocmp(const Word& a, const Word& b);
private:
	string ori;
	string dic;
	int tim;
};

bool wcmp(const Word& a, const Word& b){
	return a.dic < b.dic;
}
bool ocmp(const Word& a, const Word& b){
	return a.ori < b.ori;
}

typedef vector<Word> wordlist;
wordlist rbuf;
wordlist pbuf;

void Read(wordlist& rbuf){
	string buf;rbuf.clear();
	while (cin >> buf){
		if (buf == "#") break;
		else {
			Word w(buf);
			rbuf.push_back(w);
		}
	}
	return;
}

void Print(wordlist pbuf){
	for (int i = 0, sz = pbuf.size(); i < sz; ++i)
		cout << pbuf[i].toString() << endl;
	return;
}

void solve(){
	Read(rbuf);
	sort(rbuf.begin(),rbuf.end(),wcmp);
	pbuf.clear();
	int sz = rbuf.size();
	for (int i = 1; i < sz; ++i){
		if (rbuf[i].toDicton() == rbuf[i-1].toDicton()){
			rbuf[i].setTimes(-1);
			rbuf[i-1].setTimes(-1);
		}
		else continue;
	}
	for (int i = 0; i < sz; ++i)
		if (rbuf[i].showTimes() == 1) pbuf.push_back(rbuf[i]);
	sort(pbuf.begin(), pbuf.end(), ocmp);
	Print(pbuf);
}
int main(){
	solve();
    return 0;
}{% endhighlight %}
