---
layout: post
title: "POJ 3069 Saruman's Army 贪心"
date: 2014-06-24 17:15:45 +0800
categories: contest algorithm
tags: acmicpc poj greedy
---
题目地址<a title="POJ 3069" href="http://poj.org/problem?id=3069" target="_blank">-></a>

题目抽象出来就是用一个半径为R的圆去覆盖一条直线上的点。每个园内必须有至少一个被标记的点。问最少需要标记多少个点。

贪心去处理就行了，给从左边开始，在园内的最右边的点加上标记即可。

Code Here
{% highlight cpp %}
/**============================================================================
#       COPYRIGHT NOTICE
#       Copyright (c) 2014 All rights reserved
#       ----Stay Hungry Stay Foolish----
#
#       @author       :Shen
#       @name         :POJ 3069
#       @file         :G:My Source Code[ACM] 训练624 - 基础poj3069.cpp
#       @date         :2014-06-24 14:33
#       @algorithm    :Greedy
============================================================================**/

//#pragma GCC optimize ("O2")
//#pragma comment(linker, "/STACK:1024000000,1024000000")

#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <algorithm>
using namespace std;
template<class T>inline bool updateMin(T& a, T b){ return a > b ? a = b, 1: 0; }
template<class T>inline bool updateMax(T& a, T b){ return a < b ? a = b, 1: 0; }

typedef long long int64;

int r, n;
int x[1005];

void solve()
{
    for (int i = 0; i < n; i++)
        scanf("%d", &x[i]);
    sort(x, x + n);
    int i = 0, ans = 0;
    while (i < n)
    {
        int s = x[i++];
        while (i < n && x[i] <= s + r) i++;
        int p = x[i - 1];
        while (i < n && x[i] <= p + r) i++;
        ans++;
    }
    printf("%dn", ans);
}

int main()
{
    while (scanf("%d%d", &r, &n))
    {
        if (r == -1 && n == -1) break;
        else solve();
    }
    return 0;
}{% endhighlight %}
